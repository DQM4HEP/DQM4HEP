/// \file DQMMonitorElement.h
/*
 *
 * DQMMonitorElement.h header template automatically generated by a class generator
 * Creation date : jeu. sept. 4 2014
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Ete Remi
 * @copyright CNRS , IPNL
 */


#ifndef DQM4HEP_MONITORELEMENT_H
#define DQM4HEP_MONITORELEMENT_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"

// -- root headers
#include <TObject.h>
#include <TGraph.h>
#include <TPaveText.h>
#include <Rtypes.h>

// -- xdrstream headers
#include "xdrstream/xdrstream.h"

#include <cstddef>

namespace dqm4hep {

  namespace core {
    
    template <typename T>
    class PtrHandler
    {
    public:
      PtrHandler(T *ptr = nullptr, bool owner = true) : m_ptr(ptr), m_owner(owner) {}
      T *take() { T *ptr = m_ptr; m_ptr = nullptr; return ptr; }
      void set(T *ptr, bool owner = true) { this->clear(); m_ptr = ptr; m_owner = owner; }
      void clear() { if(m_owner && nullptr != m_ptr) delete m_ptr; m_ptr = nullptr; }
      T *ptr() const { return m_ptr; }
      bool owner() const { return m_owner; }
      
      const T *operator->() const { return m_ptr; }
      T *operator->() { return m_ptr; }
      const T &operator*() const { return *m_ptr; }
      T &operator*() { return *m_ptr; }
      operator bool() const { return m_ptr != nullptr; }
      
      template <typename S> friend bool operator ==(const PtrHandler<S> &lhs, const PtrHandler<S> &rhs);
      template <typename S> friend bool operator ==(const S *lhs, const PtrHandler<S> &rhs);
      template <typename S> friend bool operator ==(const PtrHandler<S> &lhs, const S *rhs);
      template <typename S> friend bool operator !=(const PtrHandler<S> &lhs, const PtrHandler<S> &rhs);
      template <typename S> friend bool operator !=(const S *lhs, const PtrHandler<S> &rhs);
      template <typename S> friend bool operator !=(const PtrHandler<S> &lhs, const S *rhs);

      template <typename S> friend bool operator ==(nullptr_t lhs, const PtrHandler<S> &rhs);
      template <typename S> friend bool operator ==(const PtrHandler<S> &lhs, nullptr_t rhs);
      template <typename S> friend bool operator !=(nullptr_t lhs, const PtrHandler<S> &rhs);
      template <typename S> friend bool operator !=(const PtrHandler<S> &lhs, nullptr_t rhs);
    private:
      T        *m_ptr;
      bool      m_owner;
    };
    
    template <typename T> inline bool operator ==(const PtrHandler<T> &lhs, const PtrHandler<T> &rhs) { return lhs.m_ptr == rhs.m_ptr; }
    template <typename T> inline bool operator ==(const T *lhs, const PtrHandler<T> &rhs) { return lhs == rhs.m_ptr; }
    template <typename T> inline bool operator ==(const PtrHandler<T> &lhs, const T *rhs) { return lhs.m_ptr == rhs; }
    template <typename T> inline bool operator !=(const PtrHandler<T> &lhs, const PtrHandler<T> &rhs) { return lhs.m_ptr != rhs.m_ptr; }
    template <typename T> inline bool operator !=(const T *lhs, const PtrHandler<T> &rhs) { return lhs != rhs.m_ptr; }
    template <typename T> inline bool operator !=(const PtrHandler<T> &lhs, const T *rhs) { return lhs.m_ptr != rhs; }
    
    template <typename S> inline bool operator ==(nullptr_t lhs, const PtrHandler<S> &rhs) { return lhs == rhs.m_ptr; }
    template <typename S> inline bool operator ==(const PtrHandler<S> &lhs, nullptr_t rhs) { return lhs.m_ptr == rhs; }
    template <typename S> inline bool operator !=(nullptr_t lhs, const PtrHandler<S> &rhs) { return lhs != rhs.m_ptr; }
    template <typename S> inline bool operator !=(const PtrHandler<S> &lhs, nullptr_t rhs) { return lhs.m_ptr != rhs; }

    // TODO document the MonitorElement class
    // TODO Moved the PtrHandler class to a separate file
    // 
    /**
     *  @brief  MonitorElement class
     *
     *  @author Remi Ete, DESY
     */
    class MonitorElement
    {
    public:
      
      MonitorElement();

      MonitorElement(TObject *pMonitorObject);
      
      MonitorElement(TObject *pMonitorObject, TObject *pReferenceObject);
      
      MonitorElement(const PtrHandler<TObject> &monitorObject);
      
      MonitorElement(const PtrHandler<TObject> &monitorObject, const PtrHandler<TObject> &referenceObject);
      
      std::string type() const;
      
      std::string name() const;
      
      std::string title() const;
      
      bool hasObject() const;
      
      bool hasReference() const;
      
      TObject *object();
      
      const TObject *object() const;
      
      TObject *reference();
      
      const TObject *reference() const;
      
      template <typename T>
      T *objectTo();
      
      template <typename T>
      T *referenceTo();
      
      void setMonitorObject(TObject *pMonitorObject);
      
      void setMonitorObject(const PtrHandler<TObject> &monitorObject);
      
      void setReferenceObject(TObject *pReferenceObject);

      void setReferenceObject(const PtrHandler<TObject> &referenceObject);
      
      void set(TObject *pMonitorObject, TObject *pReferenceObject);
      
      void set(const PtrHandler<TObject> &monitorObject, const PtrHandler<TObject> &referenceObject);

    private:
      PtrHandler<TObject>     m_monitorObject;
      PtrHandler<TObject>     m_referenceObject;
    };
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline T *MonitorElement::objectTo()
    {
      T *objCast = (T *) this->object(); // use old C cast for ROOT objects ...     
      return objCast ? objCast : nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    template <typename T>
    inline T *MonitorElement::referenceTo()
    {
      T *objCast = (T *) this->reference(); // use old C cast for ROOT objects ...     
      return objCast ? objCast : nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** TScalarObject class.
     *  Extension of a TObject for scalar values like int,
     *  float, double or string.
     */
    template<typename T>
    class TScalarObject : public TObject
    {
    public:

      /** Default constructor
       */
      TScalarObject();

      /** Constructor with scalar value
       */
      TScalarObject(const T &scalar);

      /** Destructor
       */
      ~TScalarObject();

      /** Clear the scalar object
       */
      void Clear(Option_t *option = "");

      /** Draw the scalar object (using a TPaveText)
       */
      void Draw(Option_t *option = "");

      /** The scalar value
       */
      void Set(const T &value);

      /** Get the scalar value
       */
      const T &Get() const;

      /** Convert the scalar value to std::string
       */
      std::string ToString() const;

    private:
      /** Initialize the scalar object (called only in C'tor)
       */
      void Init();

      T            m_scalar;       ///< The scalar value
      TPaveText   *m_pPaveText;    ///< The pave text on which to draw the scalar value

      ClassDef(TScalarObject, 1);
    };

    typedef TScalarObject<dqm_int>     TScalarInt;
    typedef TScalarObject<dqm_float>   TScalarReal;
    typedef TScalarObject<dqm_float>   TScalarFloat;
    typedef TScalarObject<dqm_double>  TScalarDouble;
    typedef TScalarObject<dqm_short>   TScalarShort;
    typedef TScalarObject<long>       TScalarLong;
    typedef TScalarObject<Long64_t>    TScalarLong64_t;
    typedef TScalarObject<std::string> TScalarString;

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** TDynamicGraph class
     *
     *  A TGraph with a dynamic x range axis
     */
    class TDynamicGraph : public TGraph
    {
    public:
      enum
      {
        kDynamicRange  = BIT(14),
        kShrinkToRange = BIT(15)
      };

      /** Constructor
       */
      TDynamicGraph();

      /** Destructor
       */
      ~TDynamicGraph();

      /** Set the range length.
       *  If kDynamicRange and kShrinkToRange bit are set
       *  then all points that do not fit the x range are removed
       */
      void SetRangeLength(Double_t rangeLength);

      /** Add a point at end of array.
       *  Remove points that do not fit the dynamic range
       *  if kDynamicRange and kShrinkToRange bit are set
       */
      void AddPoint(Double_t x, Double_t y);

      /** Draw dynamic graph. Apply dynamic range if bit set
       */
      void Draw(Option_t *option = "");

    private:
      /**
       */
      void ShrinkToRange();

    private:
      Double_t       m_rangeLength;

      ClassDef(TDynamicGraph, 1);
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    TScalarObject<T>::TScalarObject()
    {
      Init();
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    TScalarObject<T>::TScalarObject(const T &scalar) :
    m_scalar(scalar),
    m_pPaveText(0)
    {

    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    TScalarObject<T>::~TScalarObject()
    {
      if(0 != m_pPaveText)
      {
        delete m_pPaveText;
        m_pPaveText = 0;
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    void TScalarObject<T>::Clear(Option_t *option)
    {
      if(0 != m_pPaveText)
        m_pPaveText->Clear(option);

      m_scalar = 0;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    void TScalarObject<T>::Draw(Option_t *option)
    {
      std::string scalarStr = ToString();

      if(0 == m_pPaveText)
      {
        m_pPaveText = new TPaveText(0.1, 0.1, 0.9, 0.9, "NDC");
        m_pPaveText->SetFillColor(0);
        m_pPaveText->SetBorderSize(0);
        m_pPaveText->SetShadowColor(0);
      }

      m_pPaveText->Clear();
      m_pPaveText->AddText(scalarStr.c_str());
      m_pPaveText->SetTextAlign(11);
      m_pPaveText->Draw(option);
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    void TScalarObject<T>::Set(const T &value)
    {
      m_scalar = value;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    const T &TScalarObject<T>::Get() const
    {
      return m_scalar;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    std::string TScalarObject<T>::ToString() const
    {
      std::stringstream ss;
      ss << m_scalar;
      return ss.str();
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    void TScalarObject<T>::Init()
    {
      m_scalar = 0;
      m_pPaveText = 0;
    }

    //-------------------------------------------------------------------------------------------------
    // template specialization for std::string
    //-------------------------------------------------------------------------------------------------

    template <>
    inline void TScalarObject<std::string>::Clear(Option_t *option)
    {
      if(NULL != m_pPaveText)
        m_pPaveText->Clear(option);

      m_scalar.clear();
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline std::string TScalarObject<std::string>::ToString() const
    {
      return m_scalar;
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void TScalarObject<std::string>::Init()
    {
      m_scalar = "";
      m_pPaveText = 0;
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void TScalarObject<std::string>::Draw(Option_t *option)
    {
      StringVector lines;
      DQM4HEP::tokenize( m_scalar , lines , "\n" );

      if(0 == m_pPaveText)
      {
        m_pPaveText = new TPaveText(0.1, 0.1, 0.9, 0.9, "NDC");
        m_pPaveText->SetFillColor(0);
        m_pPaveText->SetBorderSize(0);
        m_pPaveText->SetShadowColor(0);
      }

      m_pPaveText->Clear();

      for(auto iter = lines.begin(), endIter = lines.end() ; endIter != iter ; ++iter)
        m_pPaveText->AddText( (*iter).c_str() );

      m_pPaveText->Draw(option);
    }

  }

}

#endif  //  DQM4HEP_MONITORELEMENT_H
