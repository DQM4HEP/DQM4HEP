/// \file DQMAlertSystem.h
/*
 *
 * DQMAlertSystem.h header template automatically generated by a class generator
 * Creation date : mar. mars 22 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQM4HEP_ALERTSYSTEM_H
#define DQM4HEP_ALERTSYSTEM_H

#include "xdrstream/xdrstream.h"

#include "dqm4hep/DQM4HEP.h"

#include "dis.hxx"
#include "dic.hxx"

namespace dqm4hep {

  namespace core {

    /** AlertSystem class
     */
    class Alert : public xdrstream::Streamable
    {
    public:
      /** Constructor
       */
      Alert();

      /** Constructor with alert attributes
       */
      Alert(const std::string &emitter, AlertType type,
          const std::string &message = "", const MonitorElementPtr &monitorElement = nullptr);

      /** Destructor
       */
      ~Alert();

      /** Get the alert emitter name
       */
      const std::string &getEmitter() const;

      /** Get alert type
       */
      AlertType getType() const;

      /** Set the alert type
       */
      void setType(AlertType type);

      /** Set the alert message
       */
      void setMessage(const std::string &message);

      /** Get the alert message
       */
      const std::string &getMessage() const;

      /** Get the monitor element associated to the alert.
       *  May be nullptr.
       */
      const MonitorElementPtr &getMonitorElement() const;

      /** Set the monitor element associated to the alert (not mandatory)
       */
      void setMonitorElement(const MonitorElementPtr &monitorElement);

      xdrstream::Status stream(xdrstream::StreamingMode mode, xdrstream::IODevice *pDevice,
          xdrstream::xdr_version_t version = 0);

    private:
      std::string                    m_emitter;
      AlertType                      m_type;
      std::string                    m_message;
      MonitorElementPtr              m_monitorElement;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** AlertNotifier class
     */
    class AlertNotifier
    {
    public:
      /** Constructor with emitter name
       */
      AlertNotifier(const std::string &emitter);

      /**
       */
      virtual ~AlertNotifier();

      /**
       */
      const std::string &getEmitter() const;

      /**
       */
      StatusCode notify(AlertType type, const std::string &message, const MonitorElementPtr &monitorElement = nullptr);

      /**
       */
      void setMinAlertInterval(int nSeconds);

    public:
      /**
       */
      virtual StatusCode startService() = 0;

      /**
       */
      virtual StatusCode stopService() = 0;

      /**
       */
      virtual bool isRunning() const = 0;

    protected:
      /** Send alert notification to clients
       */
      virtual StatusCode userNotify(AlertType type, const std::string &message,
          const MonitorElementPtr &monitorElement = nullptr ) = 0;

    private:
      std::string                      m_emitter;
      int                              m_minAlertInterval;
      time_t                           m_lastNotificationTime;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** DimAlertNotifier class
     */
    class DimAlertNotifier : public AlertNotifier
    {
    public:
      /** Constructor with emitter name
       */
      DimAlertNotifier(const std::string &emitter);

      /**
       */
      ~DimAlertNotifier();

      /**
       */
      StatusCode startService();

      /**
       */
      StatusCode stopService();

      /**
       */
      bool isRunning() const;

    protected:
      StatusCode userNotify(AlertType type, const std::string &message,
          const MonitorElementPtr &monitorElement = nullptr);

    private:
      DimService                    *m_pNotificationService;
      bool                           m_isRunning;
      xdrstream::BufferDevice       *m_pBuffer;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** AlertListener class
     */
    class AlertListener
    {
    public:
      /** Destructor
       */
      virtual ~AlertListener();

      /** Call back method on alert reception
       */
      virtual void onAlert(AlertPtr alert) = 0;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /**
     */
    class AlertHandler
    {
    public:
      /**
       */
      virtual ~AlertHandler();

      /**
       */
      void addListener(AlertListener *pListener);

      /**
       */
      void removeListener(AlertListener *pListener);

      /**
       */
      virtual StatusCode connectToService() = 0;

      /**
       */
      virtual StatusCode disconnectFromService() = 0;

      /**
       */
      virtual bool isConnected() const = 0;

    protected:
      /**
       */
      void notifyListeners(AlertPtr alert);

    private:
      std::set<AlertListener *>              m_listeners;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /**
     */
    class DimAlertHandler : public AlertHandler, public DimClient
    {
    public:
      /**
       */
      DimAlertHandler(const std::string &emitter);

      /**
       */
      ~DimAlertHandler();

      /**
       */
      const std::string &getEmitter() const;

      StatusCode connectToService();
      StatusCode disconnectFromService();
      bool isConnected() const;

    private:
      /**
       */
      void configureInBuffer(char *pBuffer, xdrstream::xdr_size_t bufferSize);

      void infoHandler();

    private:
      bool                                     m_isConnected;
      std::string                              m_emitter;
      DimUpdatedInfo                          *m_pAlertInfo;
      xdrstream::BufferDevice                 *m_pBuffer;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /**
     */
    class DimAlertInterface : public AlertHandler, public DimClient, public DimTimer
    {
    public:
      /**
       */
      DimAlertInterface();

      /**
       */
      virtual ~DimAlertInterface();

      /**
       */
      virtual void newEmitterRegistered(const std::string &emitter);

      /**
       */
      virtual void emitterUnregistered(const std::string &emitter);

      /**
       */
      void setUpdateTime(int updateTime);

      /**
       */
      StatusCode connectToService();

      /**
       */
      StatusCode disconnectFromService();

      /**
       */
      bool isConnected() const;

    private:
      void infoHandler();
      void timerHandler();

      /**
       */
      StringVector browse();

      /**
       */
      void configureInBuffer(char *pBuffer, xdrstream::xdr_size_t bufferSize);

    private:
      typedef std::map<std::string, DimInfo *> EmitterInfoMap;

      EmitterInfoMap                           m_emitterInfoMap;
      xdrstream::BufferDevice                 *m_pBuffer;
      int                                      m_updateTime;
      bool                                     m_isConnected;
    };

    // TODO Add documentation
    // TODO implement DQMModuleApi alert methods + Module application

  }
}

#endif  //  DQM4HEP_ALERTSYSTEM_H
