/// \file Server.h
/*
 *
 * Server.h header template automatically generated by a class generator
 * Creation date : sam. dï¿½c. 3 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef SERVER_H
#define SERVER_H

// -- dqm4hep headers
#include "dqm4hep/Service.h"
#include "dqm4hep/RequestHandler.h"

// -- dim headers
#include "dis.hxx"

namespace dqm4hep {

  namespace net {

    /**
     * Server class
     *
     * Main interface for service and request handler registration.
     * User can create services using the createService() method.
     * Request from client side can be handled by registering a
     * request handler by providing a class method to handle the
     * request and fill a reponse.
     *
     * All created services and request handlers are started after
     * server startup.
     */
    class Server
    {
    public:
      /**
       * Constructor
       *
       * @param name the server name
       */
      Server(const std::string &name);

      /**
       * Destructor
       */
      ~Server();

      /**
       * Get the server name
       */
      const std::string &getName() const;

      /**
       * Start serving services and handling requests
       */
      void start();

      /**
       * Stop serving services and handling requests
       */
      void stop();

      /**
       * Whether the server is running
       */
      bool isRunning() const;

      /**
       * Close all service and request handlers.
       * Called from destructor
       */
      void clear();

      /**
       * Create a new service.
       * The template parameter T corresponds to the data type handled
       * by the service. Supported types :
       *  - int
       *  - float
       *  - double
       *  - std::string
       *  - Json::Value
       *  - Buffer (see Buffer struct)
       *
       * @param type the service type
       * @param name the service name
       */
      template <typename T>
      Service<T> *createService(const std::string &type, const std::string &name);

      /**
       * Create a new request handler
       *
       * @param type the request handler type
       * @param name the request handler name
       * @param pController the class instance that will handle the request
       * @param function the class method that will treat the request and provide a response
       */
      template <typename T, typename S>
      BaseRequestHandler *createRequestHandler(const std::string &type, const std::string &name,
          S *pController, void (S::*function)(const Json::Value &request, T &response));

      /**
       * Create a new command handler
       *
       * @param type the command handler type
       * @param name the command handler name
       * @param pController the class instance that will handle the command
       * @param function the class method that will treat the command
       */
      template <typename T, typename S>
      BaseRequestHandler *createCommandHandler(const std::string &type, const std::string &name,
          S *pController, void (S::*function)(const T &command));

      /**
       * Whether the target service is registered in this server
       *
       * @param type the service type
       * @param name the service name
       */
      bool isServiceRegistered(const std::string &type, const std::string &name) const;

      /**
       * Whether the request handler is registered in this server
       *
       * @param type the request handler type
       * @param name the request handler name
       */
      bool isRequestHandlerRegistered(const std::string &type, const std::string &name) const;

      /**
       * Whether the command handler is registered in this server
       *
       * @param type the command handler type
       * @param name the command handler name
       */
      bool isCommandHandlerRegistered(const std::string &type, const std::string &name) const;

      /**
       * Start a target service
       *
       * @param type the service type
       * @param name the service name
       */
      void startService(const std::string &type, const std::string &name);

      /**
       * Stop a target service
       *
       * @param type the service type
       * @param name the service name
       */
      void stopService(const std::string &type, const std::string &name);

      /**
       * Start a target request handler
       *
       * @param type the request handler type
       * @param name the request handler name
       */
      void startRequestHandler(const std::string &type, const std::string &name);

      /**
       * Stop a target request handler
       *
       * @param type the request handler type
       * @param name the request handler name
       */
      void stopRequestHandler(const std::string &type, const std::string &name);

      /**
       * Start a target request handler
       *
       * @param type the command type
       * @param name the command name
       */
      void startCommandHandler(const std::string &type, const std::string &name);

      /**
       * Stop a target command handler
       *
       * @param type the command handler type
       * @param name the command handler name
       */
      void stopCommandHandler(const std::string &type, const std::string &name);

      /**
       * Get a created service in this server
       *
       * @param type the service type
       * @param name the service name
       */
      BaseService *getService(const std::string &type, const std::string &name) const;

      /**
      * Get a created request handler in this server
      *
      * @param type the request handler type
      * @param name the request handler name
       */
      BaseRequestHandler *getRequestHandler(const std::string &type, const std::string &name) const;

      /**
      * Get a created command handler in this server
      *
      * @param type the command handler type
      * @param name the command handler name
       */
      BaseRequestHandler *getCommandHandler(const std::string &type, const std::string &name) const;

      /**
       * Get the dim dns node.
       *  First look at DimServer::getDnsNode() then
       *  environment variable "DIM_DNS_NODE"
       */
      static std::string getDnsNode();

      /**
       * Get the dim dns port
       */
      static int getDnsPort();

      /**
       * Get the full server name as allocated on the network
       *
       * @param serverName the 'short' server name as provided in the constructor
       */
      static std::string getFullServerName(const std::string &serverName);

      /**
       * Get the list of running servers
       */
      static std::vector<std::string> getRunningServers();

      /**
       * Whether the target server is already running on the network
       *
       * @param serverName the 'short' server name
       */
      static bool isServerRunning(const std::string &serverName);

      /**
       * Whether the service is already running on the network
       *
       * @param type the service type
       * @param name the service name
       */
      static bool serviceAlreadyRunning(const std::string &type, const std::string &name);

      /**
       * Whether the request handler is already running on the network
       *
       * @param type the request handler type
       * @param name the request handler name
       */
      static bool requestHandlerAlreadyRunning(const std::string &type, const std::string &name);

      /**
       * Whether the command handler is already running on the network
       *
       * @param type the command handler type
       * @param name the command handler name
       */
      static bool commandHandlerAlreadyRunning(const std::string &type, const std::string &name);

    private:
      /**
       * Callback function to treat the server info request
       *
       * @param request the json value describing the request
       * @param response the json value descring the response to receive
       */
      void handleServerInfoRequest(const Json::Value &request, Json::Value &response);

    private:
      typedef std::map<std::string, BaseService *>         ServiceMap;
      typedef std::map<std::string, BaseRequestHandler *>  RequestHandlerMap;

      std::string                                    m_name;                 ///< The short server name
      bool                                           m_started;              ///< Whether the server has been started
      ServiceMap                                     m_serviceMap;           ///< The map of registered services
      RequestHandlerMap                              m_requestHandlerMap;    ///< The map of registered request handlers
      RequestHandlerMap                              m_commandHandlerMap;    ///< The map of registered command handlers
      RequestHandlerT<Json::Value, Server>           m_serverInfoHandler;    ///< The built-in request handler for server info
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline Service<T> *Server::createService(const std::string &type, const std::string &name)
    {
      const std::string fullServiceName(BaseService::getFullServiceName(type, name));

      auto findIter = m_serviceMap.find(fullServiceName);

      if(findIter != m_serviceMap.end())
        return dynamic_cast<Service<T>*>(findIter->second);

      if(Server::serviceAlreadyRunning(type, name))
        throw std::runtime_error("Server::createService(): service '" + fullServiceName + "' already running on network");

      // first insert nullptr, then create the service
      std::pair<ServiceMap::iterator, bool> inserted = m_serviceMap.insert(ServiceMap::value_type(fullServiceName, nullptr));

      if(inserted.second)
      {
        Service<T> *pService = new Service<T>(this, type, name);
        inserted.first->second = pService;

        if(this->isRunning())
          pService->connectService();

        return pService;
      }
      else
        throw;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T, typename S>
    inline BaseRequestHandler *Server::createRequestHandler(const std::string &type, const std::string &name,
        S *pController, void (S::*function)(const Json::Value &request, T &response))
    {
      const std::string fullRequestHandlerName(BaseRequestHandler::getFullRequestHandlerName(type, name));

      auto findIter = m_requestHandlerMap.find(fullRequestHandlerName);

      if(findIter != m_requestHandlerMap.end())
        return findIter->second;

      if(Server::requestHandlerAlreadyRunning(type, name))
        throw std::runtime_error("Server::createRequestHandler(): request handler '" + fullRequestHandlerName + "' already running on network");

      // first insert nullptr, then create request handler
      std::pair<RequestHandlerMap::iterator, bool> inserted = m_requestHandlerMap.insert(RequestHandlerMap::value_type(fullRequestHandlerName, nullptr));

      if(inserted.second)
      {
        RequestHandlerT<T,S> *pRequestHandler = new RequestHandlerT<T,S>(this, type, name, pController, function);
        inserted.first->second = pRequestHandler;

        if(this->isRunning())
          pRequestHandler->startHandlingRequest();

        return pRequestHandler;
      }
      else
        throw;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T, typename S>
    inline BaseRequestHandler *Server::createCommandHandler(const std::string &type, const std::string &name,
        S *pController, void (S::*function)(const T &command))
    {
      const std::string fullRequestHandlerName(BaseRequestHandler::getFullRequestHandlerName(type, name));

      auto findIter = m_commandHandlerMap.find(fullRequestHandlerName);

      if(findIter != m_commandHandlerMap.end())
        return findIter->second;

      if(Server::commandHandlerAlreadyRunning(type, name))
        throw std::runtime_error("Server::createCommandHandler(): command handler '" + fullRequestHandlerName + "' already running on network");

      // first insert nullptr, then create command handler
      std::pair<RequestHandlerMap::iterator, bool> inserted = m_commandHandlerMap.insert(RequestHandlerMap::value_type(fullRequestHandlerName, nullptr));

      if(inserted.second)
      {
        CommandHandlerT<T,S> *pCommandHandler = new CommandHandlerT<T,S>(this, type, name, pController, function);
        inserted.first->second = pCommandHandler;

        if(this->isRunning())
          pCommandHandler->startHandlingRequest();

        return pCommandHandler;
      }
      else
        throw;
    }
  }

}

#endif  //  SERVER_H
