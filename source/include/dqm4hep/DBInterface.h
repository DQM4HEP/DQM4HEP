/// \file DQMDBInterface.h
/*
 *
 * DQMDBInterface.h header template automatically generated by a class generator
 * Creation date : lun. janv. 11 2016
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQMDBINTERFACE_H
#define DQMDBINTERFACE_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/Logging.h"

// -- mysql headers
#include <mysql.h>

namespace dqm4hep {

  namespace core {

    /** DBInterface class
     */
    class DBInterface
    {
    public:
      /** Constructor
       */
      DBInterface();

      /** Constructor. Connect to data base
       */
      DBInterface(const std::string &host, const std::string &user, const std::string &password, const std::string &database);

      /** Destructor
       */
      virtual ~DBInterface();

      // GENERAL DATABASE
      // INTERFACE IMPLEMENTATION

      /** Connect to the mysql server
       */
      StatusCode connect();

      /** Disconnect from the database
       */
      StatusCode disconnect();

      /** Connect to the database.
       *  Not possible if a connection is being handled.
       *  Use disconnect() first and then connect()
       */
      StatusCode connect(const std::string &host, const std::string &user, const std::string &password, const std::string &database);

      /** Set host, user, password and database.
       *  Not possible if a connection is being handled.
       *  Use disconnect() first and then connect()
       */
      StatusCode set(const std::string &host, const std::string &user, const std::string &password, const std::string &database);

      /** Get the host
       */
      const std::string &getHost() const;

      /** Get the user name
       */
      const std::string &getUser() const;

      /** Get the password
       */
      const std::string &getPassword() const;

      /** Get the data base name
       */
      const std::string &getDataBase() const;

      /** Send query to database
       *  The result is not converted.
       */
      StatusCode queryRaw(const std::string &query, void *&pResult);

      /** Send query to database.
       *  The result is streamed in type T using DQM4HEP::stringToType()
       */
      template <typename T>
      StatusCode query(const std::string &query, T &result);

      /** Send query to database.
       *  The result is streamed in a vector.
       *  Each value of the vector is streamed using DQM4HEP::stringToType()
       */
      template <typename T>
      StatusCode queryVector(const std::string &query, std::vector<T> &result);

      /** Send query to database
       *  The result is passed in the handler function for user parsing
       */
      template <typename Handler>
      StatusCode queryAndHandle(const std::string &query, Handler handler);

      /** Execute the query (no result expected)
       */
      StatusCode execute(const std::string &query);

      /** Whether a connection is being handled
       */
      bool isConnected();

      // DQM4HEP SPECIFIC
      // DATABASE INTERFACE

      /** Query a config file content stored in the DQM4HEP data base (table CONFIG_FILES)
       */
      StatusCode queryConfigFileContent(const std::string &configFileName, std::string &fileContents);

      /** Query a config file description
       */
      StatusCode queryConfigFileDescription(const std::string &configFileName, std::string &fileDescription);

      /** Insert a new new config file entry in the database
       */
      StatusCode insertConfigFile(const std::string &localFileName, const std::string &fileNameEntry,
          const std::string &fileDescription = "", bool forceReplace = false);

    private:
      MYSQL                       *m_pMySQL;

      std::string                  m_host;
      std::string                  m_user;
      std::string                  m_password;
      std::string                  m_database;

      bool                         m_isConnected;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode DBInterface::query(const std::string &query, T &result)
    {
      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      if(mysql_query(m_pMySQL, query.c_str()))
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL query failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_RES *pMySQLResult = mysql_store_result(m_pMySQL);

      if(!pMySQLResult)
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL store result failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_ROW row = mysql_fetch_row(pMySQLResult);

      if(!DQM4HEP::stringToType(row[0], result))
      {
        mysql_free_result(pMySQLResult);
        return STATUS_CODE_FAILURE;
      }

      mysql_free_result(pMySQLResult);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T>
    inline StatusCode DBInterface::queryVector(const std::string &query, std::vector<T> &result)
    {
      if(!this->isConnected())
        return STATUS_CODE_NOT_INITIALIZED;

      if(mysql_query(m_pMySQL, query.c_str()))
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL query failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_RES *pMySQLResult = mysql_store_result(m_pMySQL);

      if(!pMySQLResult)
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL store result failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_ROW row;

      while( (row = mysql_fetch_row(pMySQLResult)) )
      {
        T value = T();

        if(!DQM4HEP::stringToType(row[0], value))
          continue;

        result.push_back(value);
      }

      mysql_free_result(pMySQLResult);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Handler>
    inline StatusCode DBInterface::queryAndHandle(const std::string &query, Handler handler)
    {
      if( ! this->isConnected() )
        return STATUS_CODE_NOT_INITIALIZED;

      if(mysql_query(m_pMySQL, query.c_str()))
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL query failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      MYSQL_RES *pMySQLResult = mysql_store_result(m_pMySQL);

      if(!pMySQLResult)
      {
        LOG4CXX_ERROR( dqmMainLogger , "MySQL store result failed : " << mysql_error(m_pMySQL) );
        return STATUS_CODE_FAILURE;
      }

      handler( pMySQLResult );

      mysql_free_result(pMySQLResult);

      return STATUS_CODE_SUCCESS;
    }

  }

} 

#endif  //  DQM4HEP_DBINTERFACE_H
