  /// \file MonitorObject.h
/*
 *
 * MonitorObject.h header template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 2 2017
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef MONITOROBJECT_H
#define MONITOROBJECT_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/Signal.h"

// -- json headers
#include "json/json.h"

// -- std headers
#include <bitset>

namespace dqm4hep {

  namespace core {

    class MonitorObject;

// definitions of the monitor object table
#define MONITOR_OBJECT_TABLE(d) \
    d(UNKNOWN_MONITOR_OBJECT,  "Unknown"                 , nullptr) \
    d(HISTOGRAM_1D,            "Histogram1D"             , new Histogram1D()) \
    d(GRAPH_1D,                "Graph1D"                 , new Graph1D()) \
    d(PIE_CHART,               "PieChart"                , new PieChart()) \
    d(SUMMARY,                 "Summary"                 , new Summary()) \
    d(INTEGER_OBJECT,          "Int"                     , new ScalarInt()) \
    d(UNSIGNED_INTEGER_OBJECT, "UInt"                    , new ScalarUInt()) \
    d(FLOAT_OBJECT,            "Float"                   , new ScalarFloat()) \
    d(DOUBLE_OBJECT,           "Double"                  , new ScalarDouble()) \
    d(STRING_OBJECT,           "String"                  , new ScalarString()) \
    d(LONG_INTEGER_OBJECT,     "Long"                    , new ScalarLong()) \
    d(SHORT_INTEGER_OBJECT,    "Short"                   , new ScalarShort())
    // d(SCATTER_PLOT,            "ScatterPlot"             , new ScatterPlot()) \


#define GET_MO_CREATE_SWITCH(a, b, c) case a: return c;

    /** MonitorObjectType enumerator
     */
    enum MonitorObjectType
    {
      MONITOR_OBJECT_TABLE(GET_ENUM_ENTRY_2)
      NUMBER_OF_MONITOR_OBJECTS
    };

    MonitorObject *createMonitorObject(MonitorObjectType type);

    inline std::string monitorObjectTypeToString(MonitorObjectType type)
    {
      switch(type)
      {
        MONITOR_OBJECT_TABLE(GET_NAME_SWITCH_2)
        default: throw dqm4hep::core::StatusCodeException(STATUS_CODE_INVALID_PARAMETER);
      }
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /**
     * MonitorObject class
     */
    class MonitorObject
    {
    public:
      /**
       *
       */
      template <typename Type>
      static MonitorObject *create(const Json::Value &value);

    public:
     /**
      * Constructor
      */
     MonitorObject();

     /**
      * Destructor
      */
     virtual ~MonitorObject();

     /**
      * [clear description]
      * @return [description]
      */
     virtual void clear() = 0;

     /**
      * Get the update signal.
      * May be use like this :
      *
      * @code
      * monitorObject->onUpdate().connect(myClass, &MyClass::handler);
      * @endcode
      */
     Signal<int> &onUpdate();

     /**
      * [fromJson description]
      * @param value [description]
      */
     virtual void fromJson(const Json::Value &value) = 0;

     /**
      * [toJson description]
      * @param value [description]
      * @param full  [description]
      */
     virtual void toJson(Json::Value &value, bool full = true, bool resetCache = true) = 0;

     /**
      * [isUpToDate description]
      * @return [description]
      */
     virtual bool isUpToDate() const = 0;

     /**
      * Get the monitor object type
      */
     virtual MonitorObjectType getType() const;

   protected:
     /**
      * [updated description]
      * @param property [description]
      */
     void updated(int property);

   private:
      Signal<int>                                   m_updateSignal;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename Type>
    inline MonitorObject *MonitorObject::create(const Json::Value &value)
    {
      return Type::create(value);
    }

  }

}

#endif  //  MONITOROBJECT_H
