/// \file Client.h
/*
 *
 * Client.h header template automatically generated by a class generator
 * Creation date : dim. dï¿½c. 4 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef CLIENT_H
#define CLIENT_H

// -- dqm4hep headers
#include "dqm4hep/RequestHandler.h"
#include "dqm4hep/ServiceHandler.h"
#include "dqm4hep/Service.h"

// -- json headers
#include "json/json.h"

// -- dim headers
#include "dic.hxx"

// -- std headers
#include <algorithm>

namespace dqm4hep {

  namespace net {

    /**
     * Client class
     *
     * Main interface to server. User can send request to
     * a server with or without expecting a response using
     * the sendRequest() function. User can also subscribe to
     * a particular service run on a server by using the
     * subscribe() method and by providing a callback function.
     */
    class Client
    {
    public:
      /**
       * Constructor
       */
      Client();

      /**
       * Destructor
       */
      ~Client();

      /**
       * Query server information
       *
       * @param serverName the 'short' server name
       * @param serverInfo the json value describing the server information
       */
      void queryServerInfo(const std::string &serverName, Json::Value &serverInfo) const;

      /**
       * Send a request. Do not wait for any response
       *
       * @param name the request name
       * @param request the json value describing the request to send
       */
      void sendRequest(const std::string &name, const Json::Value &request) const;

      /**
       * Send a request. Wait for the server response
       * The template parameter Reponse corresponds to the
       * expected response type. Supported types are :
       *  - int
       *  - float
       *  - double
       *  - std::string
       *  - Buffer (see Buffer struct)
       *  - Json::Value
       *
       * @param name the request name
       * @param request the json value describing the request to send
       * @param response the response to receive from the server
       */
      template <typename Response>
      void sendRequest(const std::string &name, const Json::Value &request, Response &response) const;

      /**
       * Send a command.
       * The template parameter Reponse corresponds to the
       * command type. Supported types are :
       *  - int
       *  - float
       *  - double
       *  - std::string
       *  - Buffer (see Buffer struct)
       *  - Json::Value
       *
       * @param name the command name
       * @param command the command to send
       * @param blocking whether to wait for command reception on server side
       */
      template <typename Command>
      void sendCommand(const std::string &name, const Command &command, bool blocking = false) const;

      /**
       * Subscribe to target service
       *
       * @param serviceName the service name
       * @param pController the class instance that will receive the service updates
       * @param function the class method that will receive the service update
       *
       * @code{.cpp}
       * // the class callback method
       * void MyClass::myfunction(const int &integer) { ... }
       * Client *pClient = new Client();
       * pClient->subscribe<int>("service-type", "service-name", pMyClassInstance, &MyClass::myfunction)
       * @endcode
       */
      template <typename T, typename S>
      void subscribe(const std::string &serviceName, S *pController, void (S::*function)(const T &value));

      /**
       *
       */
      template <typename Controller, typename T>
      void unsubscribe(Controller *pController, void (Controller::*function)(const T &value));

      /**
       * 
       */
      template <typename Controller, typename T>
      void unsubscribe(const std::string &serviceName, Controller *pController, void (Controller::*function)(const T &value));

      /**
       * Whether this client already registered a service subscription
       *
       * @param serviceName the service name
       */
      bool hasSubscribed(const std::string &serviceName) const;

      /**
       * [numberOfSubscriptions description]
       * @param  serviceName [description]
       * @return             [description]
       */
      unsigned int numberOfSubscriptions(const std::string &serviceName) const;

    private:
      typedef std::multimap<std::string, BaseServiceHandler *>      ServiceHandlerMap;
      typedef std::vector<BaseServiceHandler *>                     ServiceHandlerList;
      ServiceHandlerMap            m_serviceHandlerMap;        ///< The service map
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename Response>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, Response &response) const
    {
      throw std::runtime_error("Client::sendRequest(): response type not supported !");
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, int &response) const
    {
      std::string emptyJson("{}");
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), response);

      Json::Value message;
      message["response"] = true;
      message["request"] = request;
      Json::FastWriter writer;
      std::string messageStr(writer.write(message));

      rpcInfo.setData(const_cast<char*>(messageStr.c_str()));
      response = rpcInfo.getInt();
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, float &response) const
    {
      std::string emptyJson("{}");
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), response);

      Json::Value message;
      message["response"] = true;
      message["request"] = request;
      Json::FastWriter writer;
      std::string messageStr(writer.write(message));

      rpcInfo.setData(const_cast<char*>(messageStr.c_str()));
      response = rpcInfo.getFloat();
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, double &response) const
    {
      std::string emptyJson("{}");
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), response);

      Json::Value message;
      message["response"] = true;
      message["request"] = request;
      Json::FastWriter writer;
      std::string messageStr(writer.write(message));

      rpcInfo.setData(const_cast<char*>(messageStr.c_str()));
      response = rpcInfo.getDouble();
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, std::string &response) const
    {
      std::string emptyJson("{}");
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), (char*)"");

      Json::Value message;
      message["response"] = true;
      message["request"] = request;
      Json::FastWriter writer;
      std::string messageStr(writer.write(message));

      rpcInfo.setData(const_cast<char*>(messageStr.c_str()));
      response = rpcInfo.getString();
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, Buffer &response) const
    {
      std::string emptyJson("{}");
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), (void*)nullptr, 0);

      Json::Value message;
      message["response"] = true;
      message["request"] = request;
      Json::FastWriter writer;
      std::string messageStr(writer.write(message));

      rpcInfo.setData(const_cast<char*>(messageStr.c_str()));
      Buffer *pBuffer = (Buffer*)rpcInfo.getData();

      if(!pBuffer || !pBuffer->m_pBuffer || pBuffer->m_bufferSize == 0)
        return;

      response.m_pBuffer = pBuffer->m_pBuffer;
      response.m_bufferSize = pBuffer->m_bufferSize;
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    inline void Client::sendRequest(const std::string &name, const Json::Value &request, Json::Value &response) const
    {
      std::string emptyJson("{}");
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), const_cast<char*>(emptyJson.c_str()));

      Json::Value message;
      message["response"] = true;
      message["request"] = request;
      Json::FastWriter writer;
      std::string messageStr(writer.write(message));

      rpcInfo.setData(const_cast<char*>(messageStr.c_str()));
      char *jsonStr = rpcInfo.getString();

      if(!jsonStr)
        return;

      Json::Reader reader;
      reader.parse(jsonStr, response);
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Command>
    void Client::sendCommand(const std::string &name, const Command &command, bool blocking) const
    {
      if(blocking)
      {
        DimClient::sendCommand(const_cast<char*>(name.c_str()), command);
      }
      else
      {
        DimClient::sendCommandNB(const_cast<char*>(name.c_str()), command);
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    void Client::sendCommand(const std::string &name, const std::string &command, bool blocking) const
    {
      if(blocking)
      {
        DimClient::sendCommand(const_cast<char*>(name.c_str()), const_cast<char*>(command.c_str()));
      }
      else
      {
        DimClient::sendCommandNB(const_cast<char*>(name.c_str()), const_cast<char*>(command.c_str()));
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    void Client::sendCommand(const std::string &name, const Buffer &command, bool blocking) const
    {
      if(blocking)
      {
        DimClient::sendCommand(const_cast<char*>(name.c_str()), (void*)command.m_pBuffer, command.m_bufferSize + sizeof(command.m_bufferSize));
      }
      else
      {
        DimClient::sendCommandNB(const_cast<char*>(name.c_str()), (void*)command.m_pBuffer, command.m_bufferSize + sizeof(command.m_bufferSize));
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <>
    void Client::sendCommand(const std::string &name, const Json::Value &command, bool blocking) const
    {
      Json::FastWriter writer;
      std::string commandStr(writer.write(command));

      if(blocking)
      {
        DimClient::sendCommand(const_cast<char*>(name.c_str()), const_cast<char*>(commandStr.c_str()));
      }
      else
      {
        DimClient::sendCommandNB(const_cast<char*>(name.c_str()), const_cast<char*>(commandStr.c_str()));
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <typename T, typename S>
    inline void Client::subscribe(const std::string &name, S *pController, void (S::*function)(const T &value))
    {
      auto findIter = std::find_if(
        m_serviceHandlerMap.begin(), m_serviceHandlerMap.end(),
        [&name, &pController, &function](const ServiceHandlerMap::value_type &value) {

        if(value.first != name)
          return false;

        ServiceHandlerT<T,S> *pHandler = dynamic_cast<ServiceHandlerT<T,S> *>(value.second);

        if(pHandler && pHandler->controller() == pController && pHandler->function() == function)
          return true;

        return false;
      });

      if(findIter != m_serviceHandlerMap.end())
        return;

      m_serviceHandlerMap.insert(
        ServiceHandlerMap::value_type(name, new ServiceHandlerT<T,S>(this, name, pController, function))
      );
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller, typename T>
    inline void Client::unsubscribe(Controller *pController, void (Controller::*function)(const T &value))
    {
      for(auto iter = m_serviceHandlerMap.begin(), endIter = m_serviceHandlerMap.end() ; endIter != iter ; ++iter)
      {
        ServiceHandlerT<T,Controller> *pHandler = dynamic_cast<ServiceHandlerT<T,Controller> *>(iter->second);

        if(pHandler && pHandler->controller() == pController && pHandler->function() == function)
        {
          delete iter->second;
          m_serviceHandlerMap.erase(iter);
          --iter;
        }
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller, typename T>
    inline void Client::unsubscribe(const std::string &serviceName, Controller *pController, void (Controller::*function)(const T &value))
    {
      for(auto iter = m_serviceHandlerMap.begin(), endIter = m_serviceHandlerMap.end() ; endIter != iter ; ++iter)
      {
        if(serviceName != iter->first)
          continue;

        ServiceHandlerT<T,Controller> *pHandler = dynamic_cast<ServiceHandlerT<T,Controller> *>(iter->second);

        if(pHandler && pHandler->controller() == pController && pHandler->function() == function)
        {
          delete iter->second;
          m_serviceHandlerMap.erase(iter);
          --iter;
        }
      }
    }

  }

}

#endif  //  CLIENT_H
