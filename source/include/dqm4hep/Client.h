/// \file Client.h
/*
 *
 * Client.h header template automatically generated by a class generator
 * Creation date : dim. dï¿½c. 4 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef CLIENT_H
#define CLIENT_H

// -- dqm4hep headers
#include "dqm4hep/DQMNet.h"
#include "dqm4hep/RequestHandler.h"
#include "dqm4hep/ServiceHandler.h"
#include "dqm4hep/Service.h"

// -- json headers
#include "json/json.h"

// -- dim headers
#include "dic.hxx"

// -- std headers
#include <algorithm>

namespace dqm4hep {

  namespace net {

    /**
     * Client class
     *
     * Main interface to server. User can send request to
     * a server with or without expecting a response using
     * the sendRequest() function. User can also subscribe to
     * a particular service run on a server by using the
     * subscribe() method and by providing a callback function.
     */
    class Client
    {
    public:
      /**
       * Constructor
       */
      Client();

      /**
       * Destructor
       */
      ~Client();

      /**
       * Query server information
       *
       * @param serverName the 'short' server name
       * @param serverInfo the json value describing the server information
       */
      void queryServerInfo(const std::string &serverName, Json::Value &serverInfo) const;

      /**
       * Send a command. Do not wait for any acknowledgment
       *
       * @param name the request name
       * @param command the request content
       */
      template <typename Request>
      void sendRequest(const std::string &name, const Request &request) const;

      /**
       * Send a request. Wait for the server response (blocking)

       * @param name the request name
       * @param request the request to send
       * @param response the response to receive from the server
       */
      template <typename Request, typename Response>
      void sendRequest(const std::string &name, const Request &request, Response &response) const;

      /**
       * Send a command.
       *
       * @param name the command name
       * @param command the command to send
       * @param blocking whether to wait for command reception on server side
       */
      template <typename Command>
      void sendCommand(const std::string &name, const Command &command, bool blocking = false) const;

      /**
       * Subscribe to target service
       *
       * @param serviceName the service name
       * @param pController the class instance that will receive the service updates
       * @param function the class method that will receive the service update
       *
       * @code{.cpp}
       * // the class callback method
       * void MyClass::myfunction(const int &integer) { ... }
       * Client *pClient = new Client();
       * pClient->subscribe<int>("service-type", "service-name", pMyClassInstance, &MyClass::myfunction)
       * @endcode
       */
      template <typename Controller>
      void subscribe(const std::string &serviceName, Controller *pController, void (Controller::*function)(const std::string &value));

      /**
       *
       */
      template <typename Controller>
      void unsubscribe(const std::string &serviceName, Controller *pController, void (Controller::*function)(const std::string &value));

      /**
       * Whether this client already registered a service subscription
       *
       * @param serviceName the service name
       */
      bool hasSubscribed(const std::string &serviceName) const;

      /**
       * [numberOfSubscriptions description]
       * @param  serviceName [description]
       * @return             [description]
       */
      unsigned int numberOfSubscriptions(const std::string &serviceName) const;

    private:
      typedef std::map<std::string, ServiceHandler *>      ServiceHandlerMap;
      typedef std::vector<ServiceHandler *>                     ServiceHandlerList;
      ServiceHandlerMap            m_serviceHandlerMap;        ///< The service map
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename Request>
    inline void Client::sendRequest(const std::string &name, const Request &request) const
    {
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), (void*)nullptr, 0);
      std::string contents;

      if(!convert<Request>::encode(contents, request))
        throw; // TODO implement exceptions

      rpcInfo.setData((void*)request.c_str(), contents.size());
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Request, typename Response>
    inline void Client::sendRequest(const std::string &name, const Request &request, Response &response) const
    {
      DimRpcInfo rpcInfo(const_cast<char*>(name.c_str()), (void*)nullptr, 0);
      std::string contents;

      if(!convert<Request>::encode(contents, request))
        throw; // TODO implement exceptions

      rpcInfo.setData((void*)contents.c_str(), contents.size());

      char *data = (char*)rpcInfo.getData();
      int size = rpcInfo.getSize();

      if(nullptr == data || size == 0)
        return;

      contents.assign(data, size);

      if(!convert<Response>::decode(contents, response))
        throw; // TODO implement exceptions
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Command>
    inline void Client::sendCommand(const std::string &name, const Command &command, bool blocking) const
    {
      std::string contents;

      if(!convert<Command>::encode(contents, command))
        throw; // TODO implement exceptions

      if(blocking)
      {
        DimClient::sendCommand(const_cast<char*>(name.c_str()), (void*)command.c_str(), contents.size());
      }
      else
      {
        DimClient::sendCommandNB(const_cast<char*>(name.c_str()), (void*)command.c_str(), contents.size());
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller>
    inline void Client::subscribe(const std::string &name, Controller *pController, void (Controller::*function)(const std::string &value))
    {
      auto findIter = m_serviceHandlerMap.find(name);

      if(findIter != m_serviceHandlerMap.end())
      {
        findIter->second->onServiceUpdate().connect(pController, function);
        return;
      }

      m_serviceHandlerMap.insert(
        ServiceHandlerMap::value_type(name, new ServiceHandler(this, name, pController, function))
      );
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller>
    inline void Client::unsubscribe(const std::string &serviceName, Controller *pController, void (Controller::*function)(const std::string &value))
    {
      for(auto iter = m_serviceHandlerMap.begin(), endIter = m_serviceHandlerMap.end() ; endIter != iter ; ++iter)
      {
        if(serviceName != iter->first)
          continue;

        if(iter->second->onServiceUpdate().disconnect(pController, function))
          break;
      }
    }

  }

}

#endif  //  CLIENT_H
