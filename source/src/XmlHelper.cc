/// \file DQMXmlHelper.cc
/*
 *
 * DQMXmlHelper.cc source template automatically generated by a class generator
 * Creation date : mar. juil. 1 2014
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/XmlHelper.h"

namespace dqm4hep {

  namespace core {

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::readXmlFile(const std::string &fileName, TiXmlDocument &document, StringMap &constants, bool processIncludes)
    {
      bool loaded = document.LoadFile(fileName);

      if(!loaded)
      {
        dqm_error( "Couldn't load xml file ['{0}', row: {1}, col: {2}] : {3}", fileName, document.ErrorRow(), document.ErrorCol(), document.ErrorDesc() );
        return STATUS_CODE_FAILURE;
      }

      TiXmlElement *root = document.RootElement();
      TiXmlElement *constantsElt = root->FirstChildElement("constants");

      if(constantsElt)
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processConstants( fileName, constantsElt, constants, processIncludes ));
      }

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processIncludeElements( fileName, root, constants ));

      return STATUS_CODE_SUCCESS;
    }

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::processConstants(const std::string &fileName, TiXmlElement *parent, StringMap &constants, bool parseIncludes)
    {
      for( TiXmlElement* child = parent->FirstChildElement() ; child ; child = child->NextSiblingElement() ) {

        if( std::string( child->Value() ) == "constant" ) {

          // process single constant
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processConstant( child , constants ) );
        }
        // need to process includes in constants section since some
        // constants may be defined in includes and could then be
        // used in next constant values
        else if ( std::string( child->Value() ) == "include" ) {

          // process the include and returns the first and last elements found in the include
          TiXmlDocument document ;
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processIncludeElement( fileName, child , constants , document ) );

          for( TiXmlElement *elt = document.FirstChildElement() ; elt ; elt =  elt->NextSiblingElement() ) {

            if ( elt->Value() == std::string( "constant" ) )
              RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processConstant( elt , constants ) );
          }
        }
      }

      return STATUS_CODE_SUCCESS;
    }

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::processConstant(TiXmlElement *element, StringMap &constants)
    {
      if( ! element->Attribute("name") ) {
        dqm_error( "XmlHelper::processConstant : constant element without name !" ) ;
        return STATUS_CODE_FAILURE;
      }

      const std::string name( element->Attribute("name") ) ;

      if( name.empty() ) {
        dqm_error( "XmlHelper::processConstant : parsed empty constant name !" ) ;
        return STATUS_CODE_FAILURE;
      }

      if( constants.end() != constants.find( name ) ) {
        dqm_error( "XMLHelper::processConstant : constant \"{0}\" defined twice !", name );
        return STATUS_CODE_ALREADY_PRESENT;
      }

      std::string value ;

      if( element->Attribute("value") ) {
        value = element->Attribute("value") ;
      }
      else {
        if( element->FirstChild() )
          value = element->FirstChild()->Value() ;
      }

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::performConstantReplacement( value, constants ) );

      if( ! constants.insert( std::map<std::string, std::string>::value_type( name , value ) ).second ) {
        dqm_error( "XMLHelper::processConstant : couldn't add constant \"{0}\" to constant map !", name );
        return STATUS_CODE_FAILURE;
      }

      dqm_debug( "XMLHelper::processConstant: Read constant \"{0}\" , value = \"{1}\"", name, value) ;

      return STATUS_CODE_SUCCESS;
    }

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::performConstantReplacement(std::string &value, const StringMap &constants)
    {
      size_t pos = value.find("${") ;
      std::string original(value);

      while( pos != std::string::npos ) {

        size_t pos2 = value.find_first_of( "}", pos+2 ) ;

        if( pos2 == std::string::npos ) {
          dqm_error( "XMLHelper::performConstantReplacement : couldn't parse constant value !" ) ;
          return STATUS_CODE_FAILURE;
        }

        const std::string key( value.substr( pos+2 , pos2-pos-2 )) ;
        auto findConstant = constants.find( key ) ;
        const std::string replacementValue( findConstant != constants.end() ? findConstant->second : "" ) ;

        if( replacementValue.empty() ) {
          dqm_error( "XMLParser::performConstantReplacement : constant \"{0}\" not found in available constants !", key );
          return STATUS_CODE_FAILURE;
        }

        value.replace( pos , (pos2+1-pos) , replacementValue ) ;
        pos2 = pos + replacementValue.size() ; // new end position after replace

        pos = value.find("${", pos2) ; // find next possible key to replace
      }

      return STATUS_CODE_SUCCESS;
    }

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::processIncludeElements(const std::string &fileName, TiXmlElement* element , const StringMap& constants)
    {
      TiXmlElement* child = element->FirstChildElement() ;

      while( 1 )
      {
          if( ! child )
              break ;

          if( child->Value() == std::string("constants") ) {

              child = child->NextSiblingElement() ;
              continue ;
          }

          if( child->Value() != std::string("include") ) {

              RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processIncludeElements( fileName, child , constants ));
              child = child->NextSiblingElement() ;
              continue ;
          }

          // process the include and returns the first and last elements found in the include
          TiXmlDocument document ;
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::processIncludeElement( fileName, child , constants , document ) );

          // add them to the xml tree
          TiXmlNode *includeAfter( child ) ;

          for( TiXmlElement *includeElement = document.FirstChildElement() ; includeElement ; includeElement =  includeElement->NextSiblingElement() ) {

              includeAfter = element->InsertAfterChild( includeAfter, *includeElement ) ;
          }

          // tricky lines :
          // 1) Remove the include element
          element->RemoveChild(child) ;
          // 2) Go to the next sibling element of the last included element to skip nested <include> elements
          child = includeAfter->NextSiblingElement() ;
      }

      return STATUS_CODE_SUCCESS;
    }

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::processIncludeElement( const std::string &fileName, TiXmlElement* element , const StringMap& constants , TiXmlDocument &document)
    {
      std::pair<TiXmlElement*, TiXmlElement*> firstAndLastElements(nullptr, nullptr) ;

      if( ! element->Attribute("ref") ) {
        dqm_error( "XmlHelper::processIncludeElement missing attribute \"ref\" in element <{0}/>", element->Value() );
        return STATUS_CODE_FAILURE;
      }

      std::string ref ( element->Attribute("ref") ) ;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::performConstantReplacement( ref, constants ) );

      if( ref.size() < 5 || ref.substr( ref.size() - 4 ) != ".xml" ) {
        dqm_error( "XMLParser::processIncludeElement invalid ref file name \"{0}\" in element <{1}/>", ref, element->Value() );
        return STATUS_CODE_FAILURE;
      }

      std::string refFileName ;

      if( ref.at(0) != '/' ) {

          // relative path case
          // prepend with current file path
          size_t idx = fileName.find_last_of("/") ;
          std::string baseFileName ;

          if( idx != std::string::npos )
          {
              baseFileName = fileName.substr( 0 , idx ) + "/" ;
          }

          refFileName = baseFileName + ref ;
      }
      else {
          refFileName = ref ;
      }

      bool loadOkay = document.LoadFile( refFileName ) ;

      if( !loadOkay ) {
        dqm_error( "XMLParser::processIncludeElement error in file [{0}, row: {1}, col: {2}] : {3}", refFileName, document.ErrorRow(), document.ErrorCol(), document.ErrorDesc() );
        return STATUS_CODE_FAILURE;
      }

      return STATUS_CODE_SUCCESS;
    }

    //----------------------------------------------------------------------------------------------------

    // StatusCode XmlHelper::createQualityTest(const Module *const pModule, const TiXmlHandle &xmlHandle, const std::string &qualityTestName)
    // {
    //   for (TiXmlElement *pXmlElement = xmlHandle.FirstChild("qualitytest").Element(); NULL != pXmlElement;
    //       pXmlElement = pXmlElement->NextSiblingElement("qualitytest"))
    //   {
    //     std::string name;
    //     RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(pXmlElement, "name", name));
    //
    //     if(name != qualityTestName)
    //       continue;
    //
    //     RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, ModuleApi::createQualityTest(pModule, pXmlElement));
    //
    //     return STATUS_CODE_SUCCESS;
    //   }
    //
    //   return STATUS_CODE_NOT_FOUND;
    // }
    //
    // //----------------------------------------------------------------------------------------------------
    //
    // StatusCode XmlHelper::bookMonitorElement(const Module *const pModule, const TiXmlHandle &xmlHandle, const std::string &meStringId,
    //     MonitorElementPtr &monitorElement)
    // {
    //   return XmlHelper::bookMonitorElement(pModule, xmlHandle, meStringId, "", monitorElement);
    // }
    //
    // //----------------------------------------------------------------------------------------------------
    //
    // StatusCode XmlHelper::bookMonitorElement(const Module *const pModule, const TiXmlHandle &xmlHandle, const std::string &meStringId,
    //     const std::string &strSuffix, MonitorElementPtr &monitorElement)
    // {
    //   for (TiXmlElement *pXmlElement = xmlHandle.FirstChild("monitorElement").Element(); NULL != pXmlElement;
    //       pXmlElement = pXmlElement->NextSiblingElement("monitorElement"))
    //   {
    //     std::string meId;
    //     RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(pXmlElement, "ID", meId));
    //
    //     if(meId != meStringId)
    //       continue;
    //
    //     std::string meName;
    //     RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(pXmlElement, "name", meName));
    //
    //     meName += strSuffix;
    //
    //     return ModuleApi::bookMonitorElement(pModule, pXmlElement, meName, monitorElement);
    //   }
    //
    //   return STATUS_CODE_NOT_FOUND;
    // }
    //
    // //----------------------------------------------------------------------------------------------------
    //
    // StatusCode XmlHelper::bookMonitorElement(const Module *const pModule, const TiXmlHandle &xmlHandle, const std::string &meStringId,
    //     unsigned int suffix, MonitorElementPtr &monitorElement)
    // {
    //   std::stringstream ss;
    //   ss << suffix;
    //
    //   return XmlHelper::bookMonitorElement(pModule, xmlHandle, meStringId, ss.str(), monitorElement);
    // }
    //
    // //----------------------------------------------------------------------------------------------------
    //
    // StatusCode XmlHelper::bookMonitorElement(const Module *const pModule, const TiXmlHandle &xmlHandle, const std::string &meStringId,
    //     MonitorElementPtr &monitorElement, const ParameterMap &parameters)
    // {
    //   for (TiXmlElement *pXmlElement = xmlHandle.FirstChild("monitorElement").Element(); NULL != pXmlElement;
    //       pXmlElement = pXmlElement->NextSiblingElement("monitorElement"))
    //   {
    //     std::string meId;
    //     RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(pXmlElement, "ID", meId));
    //
    //     if(meId != meStringId)
    //       continue;
    //
    //     return ModuleApi::bookMonitorElement(pModule, pXmlElement, monitorElement, parameters);
    //   }
    //
    //   return STATUS_CODE_NOT_FOUND;
    // }

    //----------------------------------------------------------------------------------------------------

    StatusCode XmlHelper::replaceAllXmlAttributes(TiXmlElement *pXmlElement, const ParameterMap &parameters)
    {
      for(auto paramIter = parameters.begin(), endParamIter = parameters.end() ;
          endParamIter != paramIter ; ++paramIter)
      {
        std::string key(paramIter->first);
        std::string value(paramIter->second);

        StringVector xmlElementNames;
        DQM4HEP::tokenize(key, xmlElementNames, ".");

        TiXmlElement *pCurrentElement = pXmlElement;
        bool keyIsParameter = false;

        for(unsigned int e=0 ; e<xmlElementNames.size() ; e++)
        {
          std::string subKey(xmlElementNames.at(e));
          unsigned int eltId = 0;

          size_t posStart = subKey.find("[");

          if( posStart != std::string::npos )
          {
            if( subKey.back() != ']' )
            {
              dqm_error( "Missing ']' char in '{0}'", subKey );
              return STATUS_CODE_NOT_FOUND;
            }

            std::string eltIdStr = subKey.substr( posStart+1 , subKey.size() - (posStart+1) -1 );

            if( ! DQM4HEP::stringToType( eltIdStr , eltId ) )
            {
              dqm_error( "Couldn't convert '{0}' to array id in key '{1}' !", eltIdStr, subKey);
              return STATUS_CODE_FAILURE;
            }

            subKey = subKey.substr( 0 , posStart );
          }

          // last sub key
          if( e == xmlElementNames.size()-1 )
          {
            if( keyIsParameter )
            {
              if( ! pCurrentElement->NoChildren() )
                pCurrentElement->Clear();

              TiXmlText *pText = new TiXmlText( value );
              pCurrentElement->LinkEndChild(pText);

              dqm_debug( "Parameter key '{0}' set to {1}", key, value );
            }
            else
            {
              pCurrentElement->SetAttribute( subKey , value );
              dqm_debug( "Key attribute '{0}' set to ", key, value );
            }
          }
          else
          {
            if( e == xmlElementNames.size()-2 && subKey == "parameter" )
            {
              bool found = false;
              std::string parameterName( xmlElementNames.at(e+1) );

              for (TiXmlElement *pXmlElement = pCurrentElement->FirstChildElement("parameter"); NULL != pXmlElement;
                  pXmlElement = pXmlElement->NextSiblingElement("parameter"))
              {
                std::string name;
                RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::getAttribute(pXmlElement, "name", name));

                if( name == parameterName )
                {
                  pCurrentElement = pXmlElement;
                  found = true;
                  break;
                }
              }

              if( ! found )
              {
                dqm_error( "Key '{0}', subKey '{1}' xml element not found !", key, subKey );
                return STATUS_CODE_NOT_FOUND;
              }

              keyIsParameter = true;
            }
            else
            {
              unsigned int currentElt = 0;
              TiXmlElement *pElt = pCurrentElement->FirstChildElement( subKey );

              while( pElt && currentElt < eltId )
              {
                pElt = pElt->NextSiblingElement( subKey );
                currentElt++;
              }

              pCurrentElement = pElt;
            }

            if( NULL == pCurrentElement )
            {
              dqm_error( "Key '{0}', subKey '{1}' xml element not found !", key, subKey );
              return STATUS_CODE_NOT_FOUND;
            }
          }
        }
      }

      return STATUS_CODE_SUCCESS;
    }

  }

}
