/// \file ELogInterface.cc
/*
 *
 * ELogInterface.cc source template automatically generated by a class generator
 * Creation date : mar. juin 2 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/elog/ELogInterface.h"
#include "DQMCoreConfig.h"
#include "dqm4hep/Logging.h"

// -- std headers
#include <cstdlib>

namespace dqm4hep {

  namespace core {

    ELog::ELog() :
        m_eLogCommand(DQM4HEP_ELOG_EXECUTABLE),
        m_host(""),
        m_port(80),
        m_userName(""),
        m_password(""),
        m_logbook(""),
        m_encoding(ELog::PLAIN),
        m_useSSL(false),
        m_suppresssEmailNotification(false)
    {
#ifndef DQM4HEP_USE_ELOG
      throw StatusCodeException(STATUS_CODE_FAILURE);
#endif
    }

    //-------------------------------------------------------------------------------------------------

    ELog::ELog(const std::string &host, int port) :
        m_eLogCommand(DQM4HEP_ELOG_EXECUTABLE),
        m_host(host),
        m_port(port),
        m_userName(""),
        m_password(""),
        m_logbook(""),
        m_encoding(ELog::PLAIN),
        m_useSSL(false),
        m_suppresssEmailNotification(false)
    {
#ifndef DQM4HEP_USE_ELOG
      throw StatusCodeException(STATUS_CODE_FAILURE);
#endif
    }

    //-------------------------------------------------------------------------------------------------

    ELog::ELog(const std::string &host, int port, const std::string &userName, const std::string &password) :
        m_eLogCommand(DQM4HEP_ELOG_EXECUTABLE),
        m_host(host),
        m_port(port),
        m_userName(userName),
        m_password(password),
        m_logbook(""),
        m_encoding(ELog::PLAIN),
        m_useSSL(false),
        m_suppresssEmailNotification(false)
    {
#ifndef DQM4HEP_USE_ELOG
      throw StatusCodeException(STATUS_CODE_FAILURE);
#endif
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setHost(const std::string &host)
    {
      m_host = host;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setPort(int port)
    {
      m_port = port;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setUser(const std::string &user)
    {
      m_userName = user;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setPassword(const std::string &password)
    {
      m_password = password;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setLogbook(const std::string &logbook)
    {
      m_logbook = logbook;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::useSSL(bool useSSL)
    {
      m_useSSL = useSSL;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setEncoding(Encoding encoding)
    {
      m_encoding = encoding;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::suppressEmailNotification(bool suppress)
    {
      m_suppresssEmailNotification = suppress;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::addEntry(const std::string &name, const std::string &value)
    {
      if(name.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      m_logbookEntryMap[name] = value;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::addEntry(const LogbookEntry &entry)
    {
      if(entry.first.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      m_logbookEntryMap[entry.first] = entry.second;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::addEntries(const LogbookEntryMap &entryMap)
    {
      for(LogbookEntryMap::const_iterator iter = entryMap.begin(), endIter = entryMap.end() ;
          endIter != iter ; ++iter)
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addEntry(iter->first, iter->second));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::setMessage(const std::string &message)
    {
      m_message = message;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::log()
    {
      if(!checkConsistency())
        return STATUS_CODE_FAILURE;

      if(processELogCommand())
        return STATUS_CODE_FAILURE;

      clear();

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::log(const LogbookEntryMap &entryMap, const std::string &message)
    {
      clear();
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addEntries(entryMap));
      setMessage(message);
      return this->log();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::log(const std::string &logbook)
    {
      setLogbook(logbook);
      return this->log();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ELog::log(const std::string &logbook, const LogbookEntryMap &entryMap, const std::string &message)
    {
      setLogbook(logbook);
      setMessage(message);
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, addEntries(entryMap));
      return this->log();
    }

    //-------------------------------------------------------------------------------------------------

    bool ELog::checkConsistency() const
    {
      if(m_eLogCommand.empty()
          || m_host.empty()
          || m_userName.empty()
          || m_password.empty()
          || m_logbook.empty()
          || m_logbookEntryMap.empty())
        return false;

      if(m_logbookEntryMap.size() > 50)
        return false;

      return true;
    }

    //-------------------------------------------------------------------------------------------------

    int ELog::processELogCommand() const
    {
      std::stringstream command;
      command << m_eLogCommand
          << " -h \"" << m_host << "\""
          << " -p " << m_port
          << " -u \"" << m_userName << "\" \"" << m_password << "\""
          << " -l \"" << m_logbook << "\"";

      for(LogbookEntryMap::const_iterator iter = m_logbookEntryMap.begin(), endIter = m_logbookEntryMap.end() ;
          endIter != iter ; ++iter)
      {
        command << " -a \"" << iter->first << "\"=\"" << iter->second << "\"";
      }

      command << " -n " << m_encoding;

      if(m_useSSL)
        command << " -s ";

      if(m_suppresssEmailNotification)
        command << " -x ";

      command << " \"" << m_message << "\"";

      LOG4CXX_INFO( dqmMainLogger , "Processing logbook command : '" << command.str() << "'" );
      return system(command.str().c_str());
    }

    //-------------------------------------------------------------------------------------------------

    void ELog::clear()
    {
      m_logbookEntryMap.clear();
    }

  }

} 

