/// \file DQMDirectory.cc
/*
 *
 * DQMDirectory.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/Directory.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/MonitorElement.h"
#include "dqm4hep/CoreTool.h"

namespace dqm4hep {

  namespace core {

    Directory::Directory() :
	    m_name(""),
	    m_pParentDir(NULL)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    Directory::Directory(const std::string &name, Directory *pParentDir) :
	    m_name(name),
	    m_pParentDir(pParentDir)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    Directory::~Directory()
    {
      clear();
    }

    //-------------------------------------------------------------------------------------------------

    void Directory::ls(bool recursive) const
    {
      int depth = 0;
      std::string parentDirName = m_pParentDir == NULL ? "\"\"" : m_pParentDir->m_name;

      LOG4CXX_INFO( dqmMainLogger , "Directory " << m_name << " (parent = " << parentDirName << ") :" );

      // print contents first
      for(MonitorElementPtrList::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
          endIter != iter ; ++iter)
      {
        LOG4CXX_INFO( dqmMainLogger , " [ME]  " << (*iter)->getName() );
      }

      // print sub-directories
      for(std::vector<Directory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
          endIter != iter ; ++iter)
      {
        Directory *pDirectory = *iter;

        if(recursive)
        {
          pDirectory->ls(depth+1);
        }
        else
        {
          LOG4CXX_INFO( dqmMainLogger , " [DIR] " << pDirectory->m_name );
        }
      }

      LOG4CXX_INFO( dqmMainLogger , "" );
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &Directory::getName() const
    {
      return m_name;
    }

    //-------------------------------------------------------------------------------------------------

    Directory *Directory::getParentDir() const
    {
      return m_pParentDir;
    }

    //-------------------------------------------------------------------------------------------------

    const std::vector<Directory*> &Directory::getSubDirList() const
    {
      return m_directoryList;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::mkdir(const std::string &dirName)
    {
      if(containsDir(dirName))
        return STATUS_CODE_ALREADY_PRESENT;

      if(dirName.find("/") != std::string::npos || CoreTool::containsSpecialCharacters(dirName) || dirName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      Directory *pNewDirectory = new Directory(dirName, this);
      m_directoryList.push_back(pNewDirectory);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    bool Directory::containsDir(const std::string &dirName) const
    {
      if(dirName.find("/") != std::string::npos || CoreTool::containsSpecialCharacters(dirName) || dirName.empty())
        return false;

      for(std::vector<Directory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
          endIter != iter ; ++iter)
      {
        Directory *pDirectory = *iter;

        if(pDirectory->getName() == dirName)
          return true;
      }

      return false;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::findDir(const std::string &dirName, Directory *&pDirectory) const
    {
      pDirectory = NULL;

      for(std::vector<Directory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
          endIter != iter ; ++iter)
      {
        Directory *pDir = *iter;

        if(pDir->getName() == dirName)
        {
          pDirectory = pDir;
          return STATUS_CODE_SUCCESS;
        }
      }

      return STATUS_CODE_NOT_FOUND;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::addMonitorElement(const MonitorElementPtr &monitorElement)
    {
      if(NULL == monitorElement)
        return STATUS_CODE_INVALID_PTR;

      if(containsMonitorElement(monitorElement))
        return STATUS_CODE_ALREADY_PRESENT;

      m_contentsList.push_back(monitorElement);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::findMonitorElement(const std::string &name, MonitorElementPtr &monitorElement) const
    {
      monitorElement = NULL;

      // print contents first
      for(MonitorElementPtrList::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
          endIter != iter ; ++iter)
      {
        if((*iter)->getName() == name)
        {
          monitorElement = *iter;
          return STATUS_CODE_SUCCESS;
        }
      }

      return STATUS_CODE_NOT_FOUND;
    }

    //-------------------------------------------------------------------------------------------------

    bool Directory::containsMonitorElement(const MonitorElementPtr &monitorElement) const
    {
      return containsMonitorElement(monitorElement->getName());
    }

    //-------------------------------------------------------------------------------------------------

    bool Directory::containsMonitorElement(const std::string &monitorElementName) const
    {
      MonitorElementPtr monitorElement;
      return findMonitorElement(monitorElementName, monitorElement) == STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::removeMonitorElement(const MonitorElementPtr &monitorElement)
    {
      return removeMonitorElement(monitorElement->getName());
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::removeMonitorElement(const std::string &monitorElementName)
    {
      for(MonitorElementPtrList::iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
          endIter != iter ; ++iter)
      {
        if((*iter)->getName() == monitorElementName)
        {
          m_contentsList.erase(iter);
          return STATUS_CODE_SUCCESS;
        }
      }

      return STATUS_CODE_NOT_FOUND;
    }

    //-------------------------------------------------------------------------------------------------

    const MonitorElementPtrList &Directory::getMonitorElementList() const
    {
      return m_contentsList;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::removeDir(const std::string &dirName)
    {
      for(std::vector<Directory*>::iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
          endIter != iter ; ++iter)
      {
        Directory *pDirectory = *iter;

        if(pDirectory->getName() == dirName)
        {
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->clear());
          delete pDirectory;
          m_directoryList.erase(iter);

          return STATUS_CODE_SUCCESS;
        }
      }

      return STATUS_CODE_NOT_FOUND;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Directory::clear()
    {
      m_contentsList.clear();

      for(std::vector<Directory*>::iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
          endIter != iter ; ++iter)
      {
        Directory *pDirectory = *iter;
        // clear recursively the sub dir
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->clear());
        // delete ptr
        delete pDirectory;
      }

      m_directoryList.clear();

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    Path Directory::getFullPathName() const
    {
      Path fullPath = this->getName();
      const Directory *pDir = this;

      while(1)
      {
        const Directory *pParentDir = pDir->getParentDir();

        if(NULL != pParentDir)
        {
          fullPath = pParentDir->getName() + fullPath;
          pDir = pParentDir;
        }
        else
          break;
      }

      return fullPath;
    }

    //-------------------------------------------------------------------------------------------------

    void Directory::ls(int depth) const
    {
      std::string parentDirName = m_pParentDir == NULL ? "\"\"" : m_pParentDir->m_name;

      LOG4CXX_INFO( dqmMainLogger , std::string(depth*3, ' ') << "Directory " << m_name << " (parent = " << parentDirName << ") :" );

      // print contents first
      for(MonitorElementPtrList::const_iterator iter = m_contentsList.begin(), endIter = m_contentsList.end() ;
          endIter != iter ; ++iter)
        LOG4CXX_INFO( dqmMainLogger , std::string(depth*3, ' ') << " [ME]  " << (*iter)->getName() );

      // print sub dirs
      for(std::vector<Directory*>::const_iterator iter = m_directoryList.begin(), endIter = m_directoryList.end() ;
          endIter != iter ; ++iter)
        (*iter)->ls(depth+1);
    }

    //-------------------------------------------------------------------------------------------------

    bool Directory::isRootDir() const
    {
      return (m_pParentDir == NULL);
    }

    //-------------------------------------------------------------------------------------------------

    bool Directory::isEmpty() const
    {
      return (m_directoryList.empty() && m_contentsList.empty());
    }

  }

}

