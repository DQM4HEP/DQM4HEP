/// \file DQMStorage.cc
/*
 *
 * DQMStorage.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 19 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/Storage.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/Path.h"
#include "dqm4hep/MonitorElement.h"
#include "dqm4hep/Directory.h"

namespace dqm4hep {

  namespace core {

    Storage::Storage()
    {
      m_pRootDir = new Directory("");
      m_pCurrentDir = m_pRootDir;
    }

    //-------------------------------------------------------------------------------------------------

    Storage::~Storage()
    {
      clear();

      delete m_pRootDir;
      m_pCurrentDir = NULL;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::mkdir(const std::string &dirName)
    {
      if(dirName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      Path path(dirName);

      if(!path.isValid())
        return STATUS_CODE_INVALID_PARAMETER;

      Directory *pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;
      StringVector directoryList = path.getSplitPath();

      for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
          endIter != iter ; ++iter)
      {
        std::string dirName = *iter;

        if(dirName == ".")
          continue;

        if(dirName == "..")
        {
          if(pDirectory == m_pRootDir)
            return STATUS_CODE_FAILURE;

          pDirectory = pDirectory->getParentDir();
          continue;
        }

        // if sub dir doesn't exists, create it
        if(!pDirectory->containsDir(dirName))
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->mkdir(dirName));

        // navigate forward
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findDir(dirName, pDirectory));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void Storage::cd()
    {
      m_pCurrentDir = m_pRootDir;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::cd(const std::string &dirName)
    {
      // go back to sub dir
      if(dirName.empty())
      {
        cd();
        return STATUS_CODE_SUCCESS;
      }

      Path path(dirName);

      if(!path.isValid())
        return STATUS_CODE_INVALID_PARAMETER;

      Directory *pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;
      StringVector directoryList = path.getSplitPath();

      for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
          endIter != iter ; ++iter)
      {
        std::string dirName = *iter;

        if(dirName == ".")
          continue;

        if(dirName == "..")
        {
          if(pDirectory == m_pRootDir)
            return STATUS_CODE_FAILURE;

          pDirectory = pDirectory->getParentDir();
          continue;
        }

        // navigate forward
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findDir(dirName, pDirectory));
      }

      if(NULL == pDirectory)
        return STATUS_CODE_FAILURE;

      m_pCurrentDir = pDirectory;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void Storage::ls(bool recursive) const
    {
      m_pCurrentDir->ls(recursive);
    }

    //-------------------------------------------------------------------------------------------------

    bool Storage::dirExists(const std::string &dirName) const
    {
      Directory *pDirectory = NULL;
      return findDir(dirName, pDirectory) == STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &Storage::pwd() const
    {
      return m_pCurrentDir->getName();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::goUp()
    {
      if(m_pCurrentDir->isRootDir())
        return STATUS_CODE_NOT_ALLOWED;

      m_pCurrentDir = m_pCurrentDir->getParentDir();

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::rmdir(const std::string &dirName)
    {
      if(dirName.empty())
        return STATUS_CODE_NOT_ALLOWED;

      Directory *pDirectory = NULL;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

      if(pDirectory == m_pRootDir)
        return STATUS_CODE_NOT_ALLOWED;

      std::string fullPathDirName = pDirectory->getFullPathName().getPath();
      std::string currentFullPathDirName = m_pCurrentDir->getFullPathName().getPath();
      size_t pos = currentFullPathDirName.find(fullPathDirName);

      // this mean that the directory that we try
      // to remove is a parent of the current one.
      if(pos == 0 || pos != std::string::npos)
        return STATUS_CODE_FAILURE;

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->getParentDir()->removeDir(pDirectory->getName()));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::findDir(const std::string &dirName, Directory *&pDirectory) const
    {
      pDirectory = NULL;

      // go back to sub dir
      if(dirName.empty() || dirName == "." || dirName == "./")
      {
        pDirectory = m_pCurrentDir;
        return STATUS_CODE_SUCCESS;
      }

      Path path(dirName);

      if(!path.isValid())
        return STATUS_CODE_INVALID_PARAMETER;

      pDirectory = !path.isRelative() ? m_pRootDir : m_pCurrentDir;
      StringVector directoryList = path.getSplitPath();

      for(StringVector::iterator iter = directoryList.begin(), endIter = directoryList.end() ;
          endIter != iter ; ++iter)
      {
        std::string dirName = *iter;

        if(dirName == ".")
          continue;

        if(dirName == "..")
        {
          if(pDirectory == m_pRootDir)
            return STATUS_CODE_FAILURE;

          pDirectory = pDirectory->getParentDir();
          continue;
        }

        // navigate forward
        StatusCode statusCode = pDirectory->findDir(dirName, pDirectory);

        if(statusCode != STATUS_CODE_SUCCESS)
          return statusCode;
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    Directory *Storage::getRootDirectory() const
    {
      return m_pRootDir;
    }

    //-------------------------------------------------------------------------------------------------

    Directory *Storage::getCurrentDirectory() const
    {
      return m_pCurrentDir;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::addMonitorElement(const MonitorElementPtr &monitorElement)
    {
      Path path = m_pCurrentDir->getFullPathName();
      monitorElement->setPath(path);

      return m_pCurrentDir->addMonitorElement(monitorElement);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::addMonitorElement(const std::string &dirName, const MonitorElementPtr &monitorElement)
    {
      Directory *pDirectory = NULL;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, mkdir(dirName));
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

      Path path = pDirectory->getFullPathName();
      monitorElement->setPath(path);

      return pDirectory->addMonitorElement(monitorElement);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::removeMonitorElement(const std::string &monitorElementName)
    {
      MonitorElementPtr monitorElement;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentDir->findMonitorElement(monitorElementName, monitorElement));
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pCurrentDir->removeMonitorElement(monitorElement));

      monitorElement->setPath(Path(""));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::removeMonitorElement(const std::string &dirName, const std::string &monitorElementName)
    {
      Directory *pDirectory = NULL;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

      MonitorElementPtr monitorElement;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->findMonitorElement(monitorElementName, monitorElement));
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, pDirectory->removeMonitorElement(monitorElement));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::getMonitorElement(const std::string &monitorElementName, MonitorElementPtr &monitorElement) const
    {
      monitorElement = NULL;
      return m_pCurrentDir->findMonitorElement(monitorElementName, monitorElement);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::getMonitorElement(const std::string &dirName, const std::string &monitorElementName, MonitorElementPtr &monitorElement) const
    {
      Directory *pDirectory = NULL;
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

      return pDirectory->findMonitorElement(monitorElementName, monitorElement);
    }

    //-------------------------------------------------------------------------------------------------

    bool Storage::monitorElementExists(const MonitorElementPtr &monitorElement) const
    {
      return m_pCurrentDir->containsMonitorElement(monitorElement);
    }

    //-------------------------------------------------------------------------------------------------

    bool Storage::monitorElementExists(const std::string &dirName, const MonitorElementPtr &monitorElement) const
    {
      Directory *pDirectory = NULL;

      if( ! this->dirExists(dirName) )
        return false;

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, findDir(dirName, pDirectory));

      return pDirectory->containsMonitorElement(monitorElement);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::getAllMonitorElements(MonitorElementPtrList &monitorElementList)
    {
      return Storage::recursiveContentList(m_pRootDir, monitorElementList);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::recursiveContentList(Directory *pDirectory, MonitorElementPtrList &monitorElementList)
    {
      if(NULL == pDirectory)
        return STATUS_CODE_INVALID_PTR;

      // add directory contents
      const MonitorElementPtrList &directoryMonitorElementList(pDirectory->getMonitorElementList());
      monitorElementList.insert(monitorElementList.end(), directoryMonitorElementList.begin(), directoryMonitorElementList.end());

      // get the sub dir list ...
      const std::vector<Directory*> &subDirList(pDirectory->getSubDirList());

      if( subDirList.empty() )
        return STATUS_CODE_SUCCESS;

      // ... and loop over to add the contents
      for(std::vector<Directory*>::const_iterator iter = subDirList.begin(), endIter = subDirList.end() ;
          endIter != iter ; ++iter)
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, Storage::recursiveContentList(*iter, monitorElementList));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Storage::clear()
    {
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, m_pRootDir->clear());
      m_pCurrentDir = m_pRootDir;

      return STATUS_CODE_SUCCESS;
    }

  }

}

