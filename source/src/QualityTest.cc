/// \file DQMQualityTest.cc
/*
 *
 * DQMQualityTest.cc source template automatically generated by a class generator
 * Creation date : ven. fï¿½vr. 20 2015
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/QualityTest.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/XmlHelper.h"
#include "dqm4hep/MonitorElement.h"
#include "dqm4hep/XmlHelper.h"

// -- root headers
#include "TMath.h"
#include "TH1.h"
#include "TF1.h"

namespace dqm4hep {

  namespace core {

    namespace experimental {

      QualityTestResult::QualityTestResult() :
          m_quality(NO_QUALITY),
          m_isSuccessful(true)
      {
        /* nop */
      }

      //-------------------------------------------------------------------------------------------------

      QualityTestResult::QualityTestResult(const QualityTestResult &qualityTestResult)
      {
        *this = qualityTestResult;
      }

      //-------------------------------------------------------------------------------------------------

      QualityTestResult &QualityTestResult::operator=(const QualityTestResult &qualityTestResult)
      {
        m_type = qualityTestResult.m_type;
        m_name = qualityTestResult.m_name;
        m_message = qualityTestResult.m_message;
        m_quality = qualityTestResult.m_quality;
        m_isSuccessful = qualityTestResult.m_isSuccessful;

        return *this;
      }

      //-------------------------------------------------------------------------------------------------

      void QualityTestResult::toJson(Json::Value &value) const
      {
        value["type"] = m_type;
        value["name"] = m_name;
        value["message"] = m_message;
        value["quality"] = static_cast<int>(m_quality);
        value["successful"] = m_isSuccessful;
      }

      //-------------------------------------------------------------------------------------------------

      void QualityTestResult::fromJson(const Json::Value &value)
      {
        m_type = value.get("type", m_type).asString();
        m_name = value.get("name", m_name).asString();
        m_message = value.get("message", m_message).asString();
        m_quality = static_cast<Quality>(value.get("quality", static_cast<int>(m_quality)).asInt());
        m_isSuccessful = value.get("successful", m_isSuccessful).asBool();
      }

      //-------------------------------------------------------------------------------------------------
      //-------------------------------------------------------------------------------------------------

      QualityTest::QualityTest(const std::string &name) :
  		    m_name(name),
  		    m_quality(NO_QUALITY),
  		    m_isSuccessful(true)
      {
        /* nop */
      }

      //-------------------------------------------------------------------------------------------------

      QualityTest::~QualityTest()
      {
        /* nop */
      }

      //-------------------------------------------------------------------------------------------------

      const std::string &QualityTest::getType() const
      {
        return m_type;
      }

      //-------------------------------------------------------------------------------------------------

      const std::string &QualityTest::getName() const
      {
        return m_name;
      }

      //-------------------------------------------------------------------------------------------------

      const std::string &QualityTest::getMessage() const
      {
        return m_message;
      }

      //-------------------------------------------------------------------------------------------------

      bool QualityTest::isSuccessful() const
      {
        return m_isSuccessful;
      }

      //-------------------------------------------------------------------------------------------------

      Quality QualityTest::getQuality() const
      {
        return m_quality;
      }

      //-------------------------------------------------------------------------------------------------

      StatusCode QualityTest::run(MonitorElement *pMonitorElement, QualityTestResult &result)
      {
        result.m_type = this->getType();
        result.m_name = this->getName();

        if(this->canRun(pMonitorElement))
        {
          RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, run(pMonitorElement));

          result.m_message = getMessage();
          result.m_isSuccessful = isSuccessful();
          result.m_quality = getQuality();
        }
        else
        {
          result.m_message = "Couldn't run quality test";
          result.m_isSuccessful = false;
          result.m_quality = NO_QUALITY;
        }

        return STATUS_CODE_SUCCESS;
      }

    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    QualityTestResult::QualityTestResult() :
        m_quality(NO_QUALITY),
        m_isSuccessful(true)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    QualityTestResult::QualityTestResult(const QualityTestResult &qualityTestResult)
    {
      *this = qualityTestResult;
    }

    //-------------------------------------------------------------------------------------------------

    QualityTestResult &QualityTestResult::operator=(const QualityTestResult &qualityTestResult)
    {
      m_qualityTestType = qualityTestResult.m_qualityTestType;
      m_qualityTestName = qualityTestResult.m_qualityTestName;
      m_message = qualityTestResult.m_message;
      m_quality = qualityTestResult.m_quality;
      m_isSuccessful = qualityTestResult.m_isSuccessful;

      return *this;
    }

    //-------------------------------------------------------------------------------------------------

    xdrstream::Status QualityTestResult::stream(xdrstream::StreamingMode mode, xdrstream::IODevice *pDevice,
        xdrstream::xdr_version_t version)
    {
      if( xdrstream::XDR_READ_STREAM == mode )
      {
        XDR_STREAM( pDevice->read( & m_qualityTestType ) )
		    XDR_STREAM( pDevice->read( & m_qualityTestName ) )
		    XDR_STREAM( pDevice->read( & m_message ) )

		    int32_t quality;
        XDR_STREAM( pDevice->read<int32_t>( & quality ) )
        m_quality = static_cast<Quality>(quality);

        XDR_STREAM( pDevice->read( & m_isSuccessful ) )
      }
      else
      {
        XDR_STREAM( pDevice->write( & m_qualityTestType ) )
		    XDR_STREAM( pDevice->write( & m_qualityTestName ) )
		    XDR_STREAM( pDevice->write( & m_message ) )

		    int32_t quality = static_cast<Quality>(m_quality);
        XDR_STREAM( pDevice->write<int32_t>( & quality ) )

        XDR_STREAM( pDevice->write( & m_isSuccessful ) )
      }

      return xdrstream::XDR_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    QualityTest::QualityTest(const std::string &name) :
		    m_name(name),
		    m_quality(NO_QUALITY),
		    m_isSuccessful(true)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    QualityTest::~QualityTest()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &QualityTest::getType() const
    {
      return m_type;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &QualityTest::getName() const
    {
      return m_name;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &QualityTest::getMessage() const
    {
      return m_message;
    }

    //-------------------------------------------------------------------------------------------------

    bool QualityTest::isSuccessful() const
    {
      return m_isSuccessful;
    }

    //-------------------------------------------------------------------------------------------------

    Quality QualityTest::getQuality() const
    {
      return m_quality;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode QualityTest::run(MonitorElement *pMonitorElement, QualityTestResult &result)
    {
      result.m_qualityTestType = this->getType();
      result.m_qualityTestName = this->getName();

      if(this->canRun(pMonitorElement))
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, run(pMonitorElement));

        result.m_message = getMessage();
        result.m_isSuccessful = isSuccessful();
        result.m_quality = getQuality();
      }
      else
      {
        result.m_message = "Couldn't run quality test";
        result.m_isSuccessful = false;
        result.m_quality = NO_QUALITY;
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    MeanWithinExpectedTest::MeanWithinExpectedTest(const std::string &name) :
	    QualityTest(name),
	    m_strategy(0),
	    m_xMin(0.f),
	    m_xMax(0.f),
	    m_expectedMean(0.f),
	    m_sigma(0.f)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    MeanWithinExpectedTest::~MeanWithinExpectedTest()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MeanWithinExpectedTest::readSettings(const TiXmlHandle xmlHandle)
    {
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
          "Strategy", m_strategy));

      if(0 == m_strategy)
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
            "XMin", m_xMin));

        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
            "XMax", m_xMax));
      }
      else if(1 == m_strategy)
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
            "ExpectedMean", m_expectedMean));

        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
            "Sigma", m_sigma));
      }
      else if(2 == m_strategy)
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
            "ExpectedMean", m_expectedMean));
      }
      else
        return STATUS_CODE_INVALID_PARAMETER;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MeanWithinExpectedTest::init()
    {
      /* nop */
      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MeanWithinExpectedTest::run(MonitorElement *pMonitorElement)
    {
      m_isSuccessful = false;
      m_quality = NO_QUALITY;
      m_message = "";

      TH1 *pHistogram = pMonitorElement->get<TH1>();

      if(0 == m_strategy)
      {
        float mean = pHistogram->GetMean();

        // test failed ?
        if(mean < m_xMin || mean > m_xMax)
        {
          m_quality = VERY_BAD_QUALITY;
          m_message = "Out of range !";
        }
        else
        {
          m_quality = VERY_GOOD_QUALITY;
          m_message = "";
        }

        m_isSuccessful = true;
      }
      else if(1 == m_strategy)
      {
        float chi = (pHistogram->GetMean() - m_expectedMean)/m_sigma;
        float probability = TMath::Prob(chi*chi, 1);

        m_quality = DQM4HEP::scaleToQuality(probability);
        m_isSuccessful = true;
      }
      else if(2 == m_strategy)
      {
        float chi = (pHistogram->GetMean() - m_expectedMean)/pHistogram->GetRMS();
        float probability = TMath::Prob(chi*chi, 1);

        m_quality = DQM4HEP::scaleToQuality(probability);
        m_isSuccessful = true;
      }
      else
      {
        m_isSuccessful = false;
        m_quality = NO_QUALITY;
        m_message = "Undefined strategy for this test";
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    bool MeanWithinExpectedTest::canRun(MonitorElement *pMonitorElement) const
    {
      if(NULL == pMonitorElement)
        return false;

      MonitorElementType type = pMonitorElement->getType();
      TH1 *pHistogram = pMonitorElement->get<TH1>();

      // asking for a histo 1D
      if(type < INT_HISTOGRAM_1D_ELEMENT_TYPE || type > CHAR_HISTOGRAM_1D_ELEMENT_TYPE)
        return false;

      if(NULL == pHistogram)
        return false;

      return true;
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    Chi2FitFunctionTest::Chi2FitFunctionTest(const std::string &name) :
	    QualityTest(name),
	    m_functionXMin(0.f),
	    m_functionXMax(1.f),
	    m_functionNParameters(0)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    Chi2FitFunctionTest::~Chi2FitFunctionTest()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Chi2FitFunctionTest::readSettings(const TiXmlHandle xmlHandle)
    {
      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
          "Formula", m_formula));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readVectorOfValues(xmlHandle,
          "InputParameterList", m_inputParameterList));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
          "FunctionNParameters", m_functionNParameters));

      if(!m_inputParameterList.empty() && m_inputParameterList.size() != m_functionNParameters)
        return STATUS_CODE_INVALID_PARAMETER;

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
          "FunctionXMin", m_functionXMin));

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, XmlHelper::readValue(xmlHandle,
          "FunctionXMax", m_functionXMax));

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Chi2FitFunctionTest::init()
    {
      /* nop */
      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Chi2FitFunctionTest::run(MonitorElement *pMonitorElement)
    {
      m_isSuccessful = false;
      m_quality = NO_QUALITY;
      m_message = "";

      TH1 *pHistogram = pMonitorElement->get<TH1>();

      std::string functionName = "Chi2FitFunctionTest_"+ getName() +"_fitFunction";

      // we need to remove the function from the TH1
      // since when TH1::Fit is called, the function
      // is stored in the TH1. The function is removed and deleted
      // since we don't know if the formula is the same as the user provides
      TF1 *pFitFunction = pHistogram->GetFunction(functionName.c_str());

      if(pFitFunction)
      {
        pHistogram->RecursiveRemove(pFitFunction);
        delete pFitFunction;
        pFitFunction = NULL;
      }

      // declare the fit function and fill the parameter list
      pFitFunction = new TF1(functionName.c_str(), m_formula.c_str(), m_functionXMin, m_functionXMax);//, m_functionNParameters);

      // set the parameters depending on if an
      // input has been provided or not by the user
      for(unsigned int p=0 ; p<m_functionNParameters ; p++)
        pFitFunction->SetParameter(p, m_inputParameterList.empty() ? 0 : m_inputParameterList.at(p));

      // Q for quiet
      // N for no draw
      int status = pHistogram->Fit(pFitFunction, "QN", "", m_functionXMin, m_functionXMax);

      if(status != 0)
      {
        m_message = "Try to fit function '"+ m_formula + "' with histogram '" + pMonitorElement->getName() + "'. " +
            "Fit failed and returned status " + DQM4HEP::typeToString(status);

        return STATUS_CODE_SUCCESS;
      }

      double chi2 = pFitFunction->GetChisquare();
      double proba = TMath::Prob(chi2, m_inputParameterList.size());

      m_isSuccessful = true;
      m_quality = DQM4HEP::scaleToQuality(proba);
      m_message = "Function '"+ m_formula +"' fitted on histogram '" + pMonitorElement->getName() + "' ends with the following output :\n" +
          "Chi2 = " + DQM4HEP::typeToString(chi2) + "\n" +
          "Excess probability = " + DQM4HEP::typeToString(proba) + "\n" +
          "Output parameters : \n";

      for(unsigned int p=0 ; p<m_functionNParameters ; p++)
        m_message += (" p" + DQM4HEP::typeToString(p) + " = " + DQM4HEP::typeToString(pFitFunction->GetParameter(p)) + "\n");

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    bool Chi2FitFunctionTest::canRun(MonitorElement *pMonitorElement) const
    {
      if(NULL == pMonitorElement)
        return false;

      MonitorElementType type = pMonitorElement->getType();
      TH1 *pHistogram = pMonitorElement->get<TH1>();

      // asking for a histo 1D
      if(type < INT_HISTOGRAM_1D_ELEMENT_TYPE || type > CHAR_HISTOGRAM_1D_ELEMENT_TYPE)
        return false;

      if(NULL == pHistogram)
        return false;

      return true;
    }

  }

}
