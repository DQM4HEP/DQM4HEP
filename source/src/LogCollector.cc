  /// \file LogCollector.cc
/*
 *
 * LogCollector.cc source template automatically generated by a class generator
 * Creation date : mar. mars 21 2017
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/LogCollector.h"
#include <dqm4hep/CoreTool.h>

namespace dqm4hep {

  namespace core {

    LogCollector::LogCollector() :
      m_exit(false),
      m_maxSize(1000), // 1000 logs
      m_cleaningPeriod(60), // 1 hour
      m_lastCleanup(CoreTool::now())
    {
      m_logger = Logger::mainLogger();
      m_pServer = new net::Server("LogCollector");
    }

    //-------------------------------------------------------------------------------------------------

    LogCollector::~LogCollector()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::setMaxSize(size_t maxSize)
    {
      m_maxSize = maxSize;
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::setCleaningPeriod(unsigned int period)
    {
      m_cleaningPeriod = period;
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::receiveLog(const std::string &contents)
    {
      Json::Reader reader;
      Json::Value value;

      if(!reader.parse(contents, value))
      {
        dqm_logger_error(m_logger, "Received invalid log entry. Expected json format !");
        return;
      }

      if( ! value.isMember("name") || ! value.isMember("message") || ! value.isMember("level") )
      {
        dqm_logger_error(m_logger, "Received invalid json value. Missing memebers 'name', 'message' or 'level'");
        return;
      }

      if(CoreTool::now() > m_lastCleanup + std::chrono::minutes(m_cleaningPeriod))
      {
        m_lastCleanup = CoreTool::now();
        this->clearLogs();
      }

      // update log entries
      if(m_logEntries.size() == m_maxSize)
        m_logEntries.erase(m_logEntries.begin());

      m_logEntries.push_back(value);

      // broadcast log message
      m_pLogService->update(contents);
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::run()
    {
      dqm_logger_info(m_logger, "Creating log collector services");

      m_pServer->createCommandHandler("/dqm4hep/logcollector/collect", this, &LogCollector::receiveLog);
      m_pServer->createRequestHandler("/dqm4hep/logcollector/logs", this, &LogCollector::handleLogsRequest);
      m_pLogService = m_pServer->createService("/dqm4hep/logcollector/log");
      m_pServer->start();

      dqm_logger_info(m_logger, "Running ...");

      while(!m_exit)
        sleep(1);

      dqm_logger_info(m_logger, "Exiting !");

      delete m_pServer;
      m_pLogService = nullptr; // server owns it !
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::stop()
    {
      m_exit = true;
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::clearLogs()
    {
      dqm_logger_info(m_logger, "Cleaning logs ...");
      m_logEntries.clear();
    }

    //-------------------------------------------------------------------------------------------------

    void LogCollector::handleLogsRequest(const std::string &/*request*/, std::string &response)
    {
      dqm_logger_debug(m_logger, "Handling log request");

      response = "[]";
      Json::Value requestValue, responseValue(Json::arrayValue);

      for(unsigned int i=0 ; i<m_logEntries.size() ; i++)
        responseValue[i] = m_logEntries[i];

      Json::FastWriter writer;
      response = writer.write(responseValue);
    }

  }

}
