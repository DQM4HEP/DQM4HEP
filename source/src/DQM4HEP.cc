/// \file DQM4HEP.cc
/*
 *
 * DQM4HEP.cc source template automatically generated by a class generator
 * Creation date : dim. oct. 5 2014
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "dqm4hep/DQM4HEP.h"

namespace dqm4hep {

  namespace core {

    StatusCodeException::StatusCodeException(const StatusCode statusCode) :
		    m_statusCode(statusCode)
    {
#if defined(__GNUC__) && defined(BACKTRACE)
      const size_t maxDepth = 100;
      void *stackAddresses[maxDepth];

      size_t stackDepth = backtrace(stackAddresses, maxDepth);
      char **stackStrings = backtrace_symbols(stackAddresses, stackDepth);

      m_backTrace = "\nBackTrace\n    ";

      for (size_t i = 1; i < stackDepth; ++i)
      {
        m_backTrace += stackStrings[i];
        m_backTrace += "\n    ";
      }

      free(stackStrings); // malloc()ed by backtrace_symbols
#endif
    }

    //-------------------------------------------------------------------------------------------------

    StatusCodeException::~StatusCodeException() throw()
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode StatusCodeException::getStatusCode() const
    {
      return m_statusCode;
    }

    //-------------------------------------------------------------------------------------------------

    std::string StatusCodeException::toString() const
    {
      return statusCodeToString(m_statusCode);
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &StatusCodeException::getBackTrace() const
    {
      return m_backTrace;
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    void DQM4HEP::screenSplash()
    {
      time_t t;
      time(&t);
      char *pTimeStr = new char[256];
      ctime_r(&t, pTimeStr);

      std::cout << "#######################################################" << std::endl;
      std::cout << "#" << std::endl;
      std::cout << "#                    DQM4HEP" << std::endl;
      std::cout << "#   (Data Quality Monitoring For High Energy Physics)" << std::endl;
      std::cout << "#" << std::endl;
      std::cout << "#      Version    : " << DQM4HEP_VERSION_STR << std::endl;
      std::cout << "#      Started at : " << pTimeStr ;
      std::cout << "#      Author     : R. Ete" << std::endl;
      std::cout << "#      Mail       : <rete@ipnl.in2p3.fr> " << std::endl;
      std::cout << "#" << std::endl;
      std::cout << "#######################################################" << std::endl;

      delete [] pTimeStr;
    }

    //-------------------------------------------------------------------------------------------------

    void DQM4HEP::tokenize(const std::string &inputString, StringVector &tokens, const std::string &delimiter)
    {
      std::string::size_type lastPos = inputString.find_first_not_of(delimiter, 0);
      std::string::size_type pos     = inputString.find_first_of(delimiter, lastPos);

      while ((std::string::npos != pos) || (std::string::npos != lastPos))
      {
        tokens.push_back(inputString.substr(lastPos, pos - lastPos));
        lastPos = inputString.find_first_not_of(delimiter, pos);
        pos = inputString.find_first_of(delimiter, lastPos);
      }
    }

    //-------------------------------------------------------------------------------------------------

    Quality DQM4HEP::scaleToQuality(float scale)
    {
      if(scale > 0.f && scale < 0.2f)
        return VERY_BAD_QUALITY;
      else if(scale < 0.4f)
        return BAD_QUALITY;
      else if(scale < 0.6f)
        return NORMAL_QUALITY;
      else if(scale < 0.8f)
        return GOOD_QUALITY;
      else if(scale < 1.f)
        return VERY_GOOD_QUALITY;
      else
        return NO_QUALITY;
    }

    //-------------------------------------------------------------------------------------------------

    std::string &DQM4HEP::replace(std::string &str, const std::string &variable, const std::string &value)
    {
      std::string replaceVar = "${" + variable + "}";
      size_t pos = str.find(replaceVar);

      while( pos != std::string::npos )
      {
        str.replace( pos , replaceVar.size() , value );
        pos = str.find(replaceVar);
      }

      return str;
    }

    //-------------------------------------------------------------------------------------------------

    std::string &DQM4HEP::replace(std::string &str, const ParameterMap &parameters)
    {
      for( auto iter = parameters.begin(), endIter = parameters.end() ;
          endIter != iter ; ++iter)
      {
        DQM4HEP::replace( str , iter->first , iter->second );
      }

      return str;
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    scoped_lock::scoped_lock(pthread_mutex_t *pMutex) :
	    m_pMutex(pMutex)
    {
      pthread_mutex_lock(m_pMutex);
    }

    //-------------------------------------------------------------------------------------------------

    scoped_lock::~scoped_lock()
    {
      pthread_mutex_unlock(m_pMutex);
    }

    //-------------------------------------------------------------------------------------------------

    void printRawBuffer(char *pBuffer, int bufferSize)
    {
      std::cout << "Size : " << bufferSize << " address : " << (void *)pBuffer << std::endl;

      for(int i=0 ; i<bufferSize ; i++)
      {
        printf("%2x", pBuffer[i]);

        if(i%30 == 0)
          std::cout << std::endl;
      }

      std::cout << std::endl;
    }

  }

}
