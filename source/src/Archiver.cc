/// \file Archiver.cc
/*
 *
 * Archiver.cc source template automatically generated by a class generator
 * Creation date : mar. oct. 7 2014
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/Archiver.h"
#include "dqm4hep/Directory.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/Storage.h"
#include "dqm4hep/MonitorElement.h"

// -- root headers
#include "TFile.h"
#include "TDirectory.h"
#include "TSystem.h"

namespace dqm4hep {

  namespace core {

    Archiver::Archiver() :
        m_fileName(""),
        m_openingMode(""),
        m_pArchiveFile(NULL),
        m_isOpened(false)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    Archiver::Archiver(const std::string &archiveFileName, const std::string &openingMode, bool allowSuffix)
    {
      THROW_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->open(archiveFileName, openingMode, allowSuffix));
    }

    //-------------------------------------------------------------------------------------------------

    Archiver::~Archiver()
    {
      if(m_isOpened)
        close();
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::open(const std::string &archiveFileName, const std::string &openingMode, bool allowSuffix)
    {
      // if already open write the archive if not done
      // and close it before to re-open
      if(m_isOpened)
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, close());

      if(archiveFileName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      if(allowSuffix)
      {
        int fileId(0);

        size_t pos = archiveFileName.rfind(".root");

        if(std::string::npos == pos)
        {
          dqm_error( "Couldn't open archive '{0}' ! Must be a root file !", archiveFileName );
          return STATUS_CODE_INVALID_PARAMETER;
        }

        std::string baseArchiveName = archiveFileName.substr(0, pos);
        std::string fullArchiveName = archiveFileName;

        while(!gSystem->AccessPathName(fullArchiveName.c_str()))
        {
          std::stringstream ss;
          ss << baseArchiveName << "_" << fileId << ".root";
          fullArchiveName = ss.str();
          fileId ++;
        }

        m_fileName = fullArchiveName;
      }
      else
      {
        m_fileName = archiveFileName;
      }

      m_openingMode = openingMode;

      dqm_info( "Archiver::open: Opening archive {0}", m_fileName );

      m_pArchiveFile = new TFile(m_fileName.c_str(), openingMode.c_str());

      if(NULL == m_pArchiveFile)
      {
        dqm_error( "Couldn't open archive '{0}' !", m_fileName );
        return STATUS_CODE_FAILURE;
      }

      m_isOpened = true;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::close()
    {
      if(!m_isOpened)
        return STATUS_CODE_FAILURE;

      m_pArchiveFile->Close();
      delete m_pArchiveFile;

      m_pArchiveFile = NULL;

      m_isOpened = false;
      m_openingMode = "";

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::archive(Storage<MonitorElement> *pStorage, const std::string &dirName)
    {
      if(!this->isOpened())
        return STATUS_CODE_NOT_ALLOWED;

      TDirectory *pDirectory(nullptr);

      if(!dirName.empty())
      {
        pDirectory = m_pArchiveFile->mkdir(dirName.c_str());

        if(!pDirectory)
          return STATUS_CODE_FAILURE;
      }
      else
      {
        // TFile inherits from TDirectory ...
        pDirectory = m_pArchiveFile;
      }

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, recursiveFill(pStorage->root(), pDirectory));

      m_pArchiveFile->cd();
      m_pArchiveFile->Write();

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &Archiver::getFileName() const
    {
      return m_fileName;
    }

    //-------------------------------------------------------------------------------------------------

    bool Archiver::isOpened() const
    {
      return m_isOpened;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &Archiver::getOpeningMode() const
    {
      return m_openingMode;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::recursiveFill(Directory<MonitorElement> *pDirectory, TDirectory *pROOTDir)
    {
      if(nullptr == pDirectory || nullptr == pROOTDir)
        return STATUS_CODE_INVALID_PTR;

      pROOTDir->cd();

      const std::vector<Directory<MonitorElement>*> &subDirList(pDirectory->subdirs());

      if(!subDirList.empty())
      {
        for(auto iter = subDirList.begin(), endIter = subDirList.end() ; endIter != iter ; ++iter)
        {
          auto *pSubDir = *iter;
          TDirectory *pROOTSubDir = pROOTDir->mkdir(pSubDir->name().c_str());

          if(nullptr != pROOTSubDir)
          {
            RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, Archiver::recursiveFill(pSubDir, pROOTSubDir));
          }
        }
      }

      // write the monitor elements
      if( ! pDirectory->isEmpty() )
      {
        RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, Archiver::writeMonitorElements(pDirectory, pROOTDir));
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode Archiver::writeMonitorElements(Directory<MonitorElement> *pDirectory, TDirectory *pROOTDir)
    {
      if(nullptr == pDirectory || nullptr == pROOTDir)
        return STATUS_CODE_INVALID_PTR;

      pROOTDir->cd();

      const auto &monitorElementList(pDirectory->contents());

      for(auto iter = monitorElementList.begin(), endIter = monitorElementList.end() ; endIter != iter ; ++iter)
      {
        TObject *pObject = (*iter)->object();
        pROOTDir->WriteObjectAny(pObject, pObject->IsA(), (*iter)->name().c_str());
      }

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

  }

}
