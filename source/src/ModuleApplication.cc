/// \file DQMModuleApplication.cc
/*
 *
 * DQMModuleApplication.cc source template automatically generated by a class generator
 * Creation date : dim. sept. 6 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/ModuleApplication.h"
#include "dqm4hep/MonitorElementSender.h"
#include "dqm4hep/MonitorElementManager.h"

namespace dqm4hep {

  namespace core {

    ModuleApplication::ModuleApplication() :
		    m_isInitialized(false),
		    m_shouldStop(false),
		    m_pModule(NULL),
		    m_pMonitorElementManager(NULL),
		    m_pMonitorElementSender(NULL),
		    m_pAlertNotifier(NULL)
    {
      m_pMonitorElementManager = new MonitorElementManager();
      m_pMonitorElementSender = new MonitorElementSender(this);
    }

    //-------------------------------------------------------------------------------------------------

    ModuleApplication::~ModuleApplication()
    {
      delete m_pMonitorElementManager;
      delete m_pMonitorElementSender;

      if(m_pModule)
        delete m_pModule;

      if(m_pAlertNotifier)
        delete m_pAlertNotifier;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ModuleApplication::exit( int returnCode )
    {
      LOG4CXX_INFO( dqmMainLogger , "Exiting module application ..." );

      if(!this->isInitialized())
        return STATUS_CODE_NOT_INITIALIZED;

      if( returnCode >= 0 && returnCode < NUMBER_OF_STATUS_CODES )
        m_returnCode = static_cast< StatusCode >( returnCode );
      else
        m_returnCode = STATUS_CODE_FAILURE;

      this->setStopApplication(true);

      LOG4CXX_INFO( dqmMainLogger , "Exiting module application ... OK" );

      return m_returnCode;
    }

    //-------------------------------------------------------------------------------------------------

    Module *ModuleApplication::getModule() const
    {
      return m_pModule;
    }

    //-------------------------------------------------------------------------------------------------

    bool ModuleApplication::shouldStopApplication() const
    {
      return m_shouldStop;
    }

    //-------------------------------------------------------------------------------------------------

    void ModuleApplication::setStopApplication(bool stopApplication)
    {
      m_shouldStop = stopApplication;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ModuleApplication::setModuleName(const std::string &name)
    {
      if(this->isInitialized())
        return STATUS_CODE_ALREADY_INITIALIZED;

      m_moduleName = name;

      if(m_pModule)
        m_pModule->setName(name);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ModuleApplication::setModuleType(const std::string &type)
    {
      if(this->isInitialized())
        return STATUS_CODE_ALREADY_INITIALIZED;

      m_moduleType = type;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &ModuleApplication::getModuleName() const
    {
      if(m_pModule)
        return m_pModule->getName();

      return m_moduleName;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &ModuleApplication::getModuleType() const
    {
      return m_moduleType;
    }

    //-------------------------------------------------------------------------------------------------

    bool ModuleApplication::isInitialized() const
    {
      return m_isInitialized;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ModuleApplication::getReturnCode() const
    {
      return m_returnCode;
    }

    //-------------------------------------------------------------------------------------------------

    void ModuleApplication::setInitialized(bool initialized)
    {
      m_isInitialized = initialized;
    }

    //-------------------------------------------------------------------------------------------------

    MonitorElementManager *ModuleApplication::getMonitorElementManager() const
    {
      return m_pMonitorElementManager;
    }

    //-------------------------------------------------------------------------------------------------

    MonitorElementSender *ModuleApplication::getMonitorElementSender() const
    {
      return m_pMonitorElementSender;
    }

    //-------------------------------------------------------------------------------------------------

    AlertNotifier *ModuleApplication::getAlertNotifier() const
    {
      return m_pAlertNotifier;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ModuleApplication::setModule(Module *pModule)
    {
      if(!pModule)
        return STATUS_CODE_INVALID_PTR;

      m_pModule = pModule;
      m_pModule->setName(m_moduleName);
      m_pModule->setModuleApplication(this);

      RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, this->createAlertNotifier(m_moduleName))

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode ModuleApplication::createAlertNotifier(const std::string moduleName)
    {
      if( m_pAlertNotifier )
        return STATUS_CODE_ALREADY_INITIALIZED;

      m_pAlertNotifier = new DimAlertNotifier(moduleName);

      return STATUS_CODE_SUCCESS;
    }

  }

}

