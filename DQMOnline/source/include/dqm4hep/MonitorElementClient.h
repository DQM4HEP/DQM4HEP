/*
 *
 * DQMMonitorElementClient.h header template automatically generated by a class generator
 * Creation date : dim. mai 10 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQM4HEP_MONITORELEMENTCLIENT_H
#define DQM4HEP_MONITORELEMENTCLIENT_H

// -- dqm4hep headers
#include "dqm4hep/DQM4HEP.h"
#include "dqm4hep/StreamingHelper.h"

// -- dim headers
#include "dic.hxx"

namespace dqm4hep {

  namespace core {

    class MonitorElementClient;

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    class MeCollectorInfoRpcInfo : public DimRpcInfo
    {
    public:
      MeCollectorInfoRpcInfo(char *rpcInfoName, MonitorElementClient *pClient);
      void rpcInfoHandler();

    private:
      MonitorElementClient      *m_pClient;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    class MeListNameRpcInfo : public DimRpcInfo
    {
    public:
      MeListNameRpcInfo(char *rpcInfoName, MonitorElementClient *pClient);
      void rpcInfoHandler();

    private:
      MonitorElementClient      *m_pClient;
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** MonitorElementClientListener class.
     *
     *  Listeners receive notifications for each of the callback methods above
     */
    class MonitorElementClientListener
    {
    public:
      /** Destructor
       */
      virtual ~MonitorElementClientListener() {}

      /** Called back on client connection
       */
      virtual void onMonitorElementClientConnect(MonitorElementClient */*pClient*/) {}

      /** Called back on client disconnection
       */
      virtual void onMonitorElementClientDisconnect(MonitorElementClient */*pClient*/) {};

      /** Called back on server connection
       */
      virtual void onServerStartup(MonitorElementClient */*pClient*/) {}

      /** Called back when the server is shutdown
       */
      virtual void onServerShutdown(MonitorElementClient */*pClient*/) {}

      /** Called back when available me list is received
       */
      virtual void availableMonitorElementListReceived(MonitorElementClient */*pClient*/, const MonitorElementInfoList &/*infoList*/) {}

      /** Called back when me collector info is received
       */
      virtual void monitorElementCollectorInfoReceived(MonitorElementClient */*pClient*/, const HostInfo &/*collectorInfo*/) {}

      /** Called back when monitor elements are received.
       */
      virtual void monitorElementsReceived(MonitorElementClient */*pClient*/, Publication &/*publication*/) {}

      /** Called back when a module post new available monitor elements
       */
      virtual void monitorElementsAvailable(MonitorElementClient */*pClient*/, const MonitorElementInfoList &/*infoList*/) {};
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    /** MonitorElementClient class
     */
    class MonitorElementClient : public DimClient
    {
    public:
      /** Constructor
       */
      MonitorElementClient();

      /** Destructor
       */
      ~MonitorElementClient();

      /** Set the collector name. Can be done only if the client is
       *  not yet connected to collector service
       */
      StatusCode setCollectorName(const std::string &collectorName);

      /** Get the collector name
       */
      const std::string &getCollectorName() const;

      /** Connect the client to the service
       */
      StatusCode connectToService();

      /** Disconnect the client from the service
       */
      StatusCode disconnectFromService();

      /** Whether the client is connected to the service
       */
      bool isConnectedToService() const;

      /** Sent a request to the collector to get back the collector informations
       */
      StatusCode queryCollectorInfo();

      /** Send a request to get back monitor element list name (small packet info)
       */
      StatusCode queryAvailableMonitorElements(const MonitorElementListNameRequest &request);

      /** Unsubscribe to monitor elements
       */
      StatusCode subscribe(const MonitorElementRequest &request);

      /** Subscribe to monitor elements
       */
      StatusCode unsubscribe(const MonitorElementRequest &request);

      /** Unsubscribe to all monitor elements the client has already
       *  subscribed and subscribe to monitor elements
       */
      StatusCode replaceSubscription(const MonitorElementRequest &request);

      /** Send a command to query the monitor element list.
       *  The element in the list are first subscribed.
       *  Then a query is sent to update only the element in the request
       */
      StatusCode querySubscribedMonitorElements(const MonitorElementRequest &request);

      /** Send a command to query the monitor element list that the client subscribed
       */
      StatusCode querySubscribedMonitorElements();

      /** Set the update mode. If set to true, subscribed monitor elements will be received
       *  when an update is performed on the collector server side
       */
      void setUpdateMode(bool updateMode);

      /** Get the update mode
       */
      bool getUpdateMode() const;

      /** Whether the collector is running
       */
      bool isCollectorRunning() const;

      /** Add a listener to this client (observer pattern).
       */
      bool addListener(MonitorElementClientListener *pListener);

      /** Remove a listener from this client
       */
      void removeListener(MonitorElementClientListener *pListener);

    public:
      static const std::string         m_emptyBufferStr;

    private:
      /** Handle the collector info rpc callback
       */
      void handleMeCollectorInfoRpcInfo(DimRpcInfo *pRpcInfo);

      /** Handle the me name list rpc callback
       */
      void handleMeListNameRpcInfo(DimRpcInfo *pRpcInfo);

      /** Dim info handler
       */
      void infoHandler();

      /** Deep clear of publication
       */
      void clearPublication(Publication &publication);

      /**
       */
      void configureInBuffer( char *pBuffer, uint32_t size );

    private:
      DimRpcInfo                            *m_pMeCollectorInfoRpcInfo;
      DimRpcInfo                            *m_pMeListNameRpcInfo;
      DimUpdatedInfo                        *m_pMeUpdateInfo;
      DimInfo                               *m_pCollectorStateInfo;
      DimInfo                               *m_pAvailableMeInfo;

      xdrstream::BufferDevice               *m_pInBuffer;
      xdrstream::BufferDevice               *m_pOutBuffer;

      std::string                            m_collectorName;
      bool                                   m_isConnected;
      bool                                   m_updateMode;
      bool                                   m_isCollectorRunning;

      // listeners
      std::vector<MonitorElementClientListener *>    m_listeners;

      friend class MeCollectorInfoRpcInfo;
      friend class MeListNameRpcInfo;
    };

  }

}

#endif  //  DQM4HEP_MONITORELEMENTCLIENT_H
