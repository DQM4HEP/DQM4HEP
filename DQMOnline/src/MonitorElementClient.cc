/*
 *
 * DQMMonitorElementClient.cc source template automatically generated by a class generator
 * Creation date : dim. mai 10 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/MonitorElementClient.h"
#include "dqm4hep/MonitorElement.h"
#include "dqm4hep/Logging.h"

// -- std headers
#include <algorithm>

namespace dqm4hep {

  namespace core {

    MeCollectorInfoRpcInfo::MeCollectorInfoRpcInfo(char *rpcInfoName, MonitorElementClient *pClient) :
		    DimRpcInfo(rpcInfoName, (void*) MonitorElementClient::m_emptyBufferStr.c_str(), MonitorElementClient::m_emptyBufferStr.size()),
		    m_pClient(pClient)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    void MeCollectorInfoRpcInfo::rpcInfoHandler()
    {
      m_pClient->handleMeCollectorInfoRpcInfo(this);
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    MeListNameRpcInfo::MeListNameRpcInfo(char *rpcInfoName, MonitorElementClient *pClient) :
		    DimRpcInfo(rpcInfoName, (void*) MonitorElementClient::m_emptyBufferStr.c_str(), MonitorElementClient::m_emptyBufferStr.size()),
		    m_pClient(pClient)
    {
      /* nop */
    }

    //-------------------------------------------------------------------------------------------------

    void MeListNameRpcInfo::rpcInfoHandler()
    {
      m_pClient->handleMeListNameRpcInfo(this);
    }

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    const std::string MonitorElementClient::m_emptyBufferStr = "EMPTY";

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    MonitorElementClient::MonitorElementClient() :
		    m_isConnected(false),
		    m_pMeCollectorInfoRpcInfo(NULL),
		    m_pMeListNameRpcInfo(NULL),
		    m_pInBuffer(0),
		    m_pOutBuffer(0),
		    m_updateMode(false),
		    m_isCollectorRunning(false)
    {
      m_pOutBuffer = new xdrstream::BufferDevice(1024*1024);
    }

    //-------------------------------------------------------------------------------------------------

    MonitorElementClient::~MonitorElementClient()
    {
      if(isConnectedToService())
        disconnectFromService();

      delete m_pOutBuffer;

      if( m_pInBuffer )
        delete m_pInBuffer;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::setCollectorName(const std::string &collectorName)
    {
      if(collectorName.empty())
        return STATUS_CODE_INVALID_PARAMETER;

      if(isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      m_collectorName = collectorName;

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    const std::string &MonitorElementClient::getCollectorName() const
    {
      return m_collectorName;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::connectToService()
    {
      if(isConnectedToService())
        return STATUS_CODE_SUCCESS;

      std::string collectorName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
      std::stringstream ss;

      ss << collectorName << "COLLECTOR_INFO_RPC";
      m_pMeCollectorInfoRpcInfo = new MeCollectorInfoRpcInfo((char*) ss.str().c_str(), this);

      ss.str("");
      ss << collectorName << "MONITOR_ELEMENT_NAME_LIST_RPC";
      m_pMeListNameRpcInfo = new MeListNameRpcInfo((char*) ss.str().c_str(), this);

      ss.str("");
      ss << collectorName << "ME_UPDATE_SVC";
      m_pMeUpdateInfo = new DimUpdatedInfo( (char*) ss.str().c_str() , (void *) NULL , 0, this );

      ss.str("");
      ss << collectorName << "COLLECTOR_STATE_SVC";
      m_pCollectorStateInfo = new DimInfo( (char*) ss.str().c_str() , static_cast<int>(STOPPED_STATE) , this );

      ss.str("");
      ss << collectorName << "AVAILABLE_ME_SVC";
      m_pAvailableMeInfo = new DimUpdatedInfo( (char*) ss.str().c_str() , (void *) NULL , 0, this );

      m_isConnected = true;

      this->setUpdateMode(this->getUpdateMode());

      for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
          endIter != iter ; ++iter)
        (*iter)->onMonitorElementClientConnect(this);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::disconnectFromService()
    {
      if(!isConnectedToService())
        return STATUS_CODE_SUCCESS;

      delete m_pMeCollectorInfoRpcInfo; m_pMeCollectorInfoRpcInfo = NULL;
      delete m_pMeListNameRpcInfo; m_pMeListNameRpcInfo = NULL;
      delete m_pMeUpdateInfo; m_pMeUpdateInfo = NULL;
      delete m_pCollectorStateInfo; m_pCollectorStateInfo = NULL;
      delete m_pAvailableMeInfo; m_pAvailableMeInfo = NULL;

      m_isConnected = false;

      for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
          endIter != iter ; ++iter)
        (*iter)->onMonitorElementClientDisconnect(this);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    bool MonitorElementClient::isConnectedToService() const
    {
      return m_isConnected;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::queryCollectorInfo()
    {
      if(!isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      char buf[] = "\0";
      m_pMeCollectorInfoRpcInfo->setData((void *) &buf[0], 1);

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::queryAvailableMonitorElements(const MonitorElementListNameRequest &request)
    {
      if(!isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      // serialize the list
      m_pOutBuffer->reset();

      if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , request ) )
      {
        LOG4CXX_WARN( dqmMainLogger , "Couldn't write available list request" );
        return STATUS_CODE_FAILURE;
      }

      // send query
      m_pMeListNameRpcInfo->setData((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition());

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::querySubscribedMonitorElements(const MonitorElementRequest &request)
    {
      if(!isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      // serialize the request
      m_pOutBuffer->reset();

      if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , request ) )
      {
        LOG4CXX_WARN( dqmMainLogger , "Couldn't write subscribed list request" );
        return STATUS_CODE_FAILURE;
      }

      // send the request
      std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/QUERY_ME_CMD";
      DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::querySubscribedMonitorElements()
    {
      // send empty request.
      MonitorElementRequest request;
      return this->querySubscribedMonitorElements(request);
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::subscribe(const MonitorElementRequest &request)
    {
      if(!isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      // serialize the request
      m_pOutBuffer->reset();

      if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , request ) )
      {
        LOG4CXX_WARN( dqmMainLogger , "Couldn't write me subscription request" );
        return STATUS_CODE_FAILURE;
      }

      // send the request
      std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/SUBSCRIBE_CMD";
      DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::unsubscribe(const MonitorElementRequest &request)
    {
      if(!isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      // serialize the request
      m_pOutBuffer->reset();

      if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , request ) )
      {
        LOG4CXX_WARN( dqmMainLogger , "Couldn't write me un-subscription request" );
        return STATUS_CODE_FAILURE;
      }

      // send the request
      std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/UNSUBSCRIBE_CMD";
      DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    StatusCode MonitorElementClient::replaceSubscription(const MonitorElementRequest &request)
    {
      if(!isConnectedToService())
        return STATUS_CODE_NOT_ALLOWED;

      // serialize the request
      m_pOutBuffer->reset();

      if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , request ) )
        return STATUS_CODE_FAILURE;

      // send the request
      std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/SET_SUBSCRIPTION_CMD";
      DimClient::sendCommandNB( commandName.c_str() , (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );

      return STATUS_CODE_SUCCESS;
    }

    //-------------------------------------------------------------------------------------------------

    void MonitorElementClient::setUpdateMode(bool updateMode)
    {
      if(this->isConnectedToService())
      {
        std::string commandName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/SET_UPDATE_MODE_CMD";
        DimClient::sendCommandNB( commandName.c_str() , static_cast<int>(updateMode) );
      }

      m_updateMode = updateMode;
    }

    //-------------------------------------------------------------------------------------------------

    bool MonitorElementClient::getUpdateMode() const
    {
      return m_updateMode;
    }

    //-------------------------------------------------------------------------------------------------

    bool MonitorElementClient::addListener(MonitorElementClientListener *pListener)
    {
      if(NULL == pListener)
        return false;

      std::vector<MonitorElementClientListener *>::iterator findIter = std::find( m_listeners.begin(), m_listeners.end(), pListener );

      // if already added, return ok
      if(m_listeners.end() != findIter)
        return true;

      m_listeners.push_back(pListener);

      return true;
    }

    //-------------------------------------------------------------------------------------------------

    void MonitorElementClient::removeListener(MonitorElementClientListener *pListener)
    {
      if(NULL == pListener)
        return;

      std::vector<MonitorElementClientListener *>::iterator findIter = std::find( m_listeners.begin(), m_listeners.end(), pListener );

      if(m_listeners.end() == findIter)
        return;

      m_listeners.erase(findIter);
    }

    //-------------------------------------------------------------------------------------------------

    void MonitorElementClient::handleMeCollectorInfoRpcInfo(DimRpcInfo *pRpcInfo)
    {
      try
      {
        if(m_listeners.empty())
          return;

        dqm_char *pBuffer = static_cast<dqm_char *>(pRpcInfo->getData());
        dqm_uint bufferSize = pRpcInfo->getSize();

        if(NULL == pBuffer || 0 == bufferSize)
          return;

        this->configureInBuffer( pBuffer , bufferSize );

        // deserialize and notify
        HostInfo collectorInfo;

        if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , collectorInfo ) )
          return;

        for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
            endIter != iter ; ++iter)
          (*iter)->monitorElementCollectorInfoReceived(this, collectorInfo);
      }
      catch(StatusCodeException &exception)
      {
      }
      catch(...)
      {
      }
    }

    //-------------------------------------------------------------------------------------------------

    void MonitorElementClient::handleMeListNameRpcInfo(DimRpcInfo *pRpcInfo)
    {
      try
      {
        if(m_listeners.empty())
          return;

        dqm_char *pBuffer = static_cast<dqm_char*>(pRpcInfo->getData());
        dqm_uint bufferSize = pRpcInfo->getSize();

        if(NULL == pBuffer || 0 == bufferSize)
          throw StatusCodeException(STATUS_CODE_FAILURE);

        this->configureInBuffer( pBuffer , bufferSize );

        // deserialize and notify
        MonitorElementInfoList monitorElementInfoList;

        if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , monitorElementInfoList ) )
          throw StatusCodeException(STATUS_CODE_FAILURE);

        for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
            endIter != iter ; ++iter)
          (*iter)->availableMonitorElementListReceived(this, monitorElementInfoList);
      }
      catch(StatusCodeException &exception)
      {
        LOG4CXX_ERROR( dqmMainLogger , "handleMeListNameRpcInfo(): Exception caught : " << exception.toString() );
      }
      catch(...)
      {
      }
    }

    //-------------------------------------------------------------------------------------------------

    void MonitorElementClient::infoHandler()
    {
      DimInfo *pInfo = getInfo();

      LOG4CXX_DEBUG( dqmMainLogger , "Received info : " << pInfo->getName() );

      if(pInfo == m_pMeUpdateInfo)
      {
        Publication monitorElementPublication;

        try
        {
          if(m_listeners.empty())
            return;

          dqm_char *pBuffer = static_cast<dqm_char *>(m_pMeUpdateInfo->getData());
          dqm_uint bufferSize = m_pMeUpdateInfo->getSize();

          if(NULL == pBuffer || 0 == bufferSize)
            throw StatusCodeException(STATUS_CODE_FAILURE);

          this->configureInBuffer( pBuffer , bufferSize );

          // deserialize and call the user call back function
          if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , monitorElementPublication ) )
            throw StatusCodeException(STATUS_CODE_FAILURE);

          for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
              endIter != iter ; ++iter)
            (*iter)->monitorElementsReceived(this, monitorElementPublication);
        }
        catch(StatusCodeException &exception)
        {
          LOG4CXX_WARN( dqmMainLogger , "Couldn't receive monitor element publication: " << exception.toString() );
        }
        catch(...)
        {
        }
      }
      else if(pInfo == m_pCollectorStateInfo)
      {
        bool isCollectorRunning = static_cast<bool>(m_pCollectorStateInfo->getInt());

        LOG4CXX_INFO( dqmMainLogger , "Received collector state : " << isCollectorRunning );

        if(isCollectorRunning == m_isCollectorRunning)
          return;

        m_isCollectorRunning = isCollectorRunning;

        if(m_isCollectorRunning)
        {
          // send back update mode info to collector
          this->setUpdateMode(this->getUpdateMode());

          // notify server state !
          for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
              endIter != iter ; ++iter)
            (*iter)->onServerStartup(this);
        }
        else
        {
          // notify server state !
          for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
              endIter != iter ; ++iter)
            (*iter)->onServerShutdown(this);
        }
      }
      else if(pInfo == m_pAvailableMeInfo)
      {
        MonitorElementInfoList availableMeList;

        try
        {
          if(m_listeners.empty())
            return;

          dqm_char *pBuffer = static_cast<dqm_char *>(m_pAvailableMeInfo->getData());
          dqm_uint bufferSize = m_pAvailableMeInfo->getSize();

          if(NULL == pBuffer || 0 == bufferSize)
            throw StatusCodeException(STATUS_CODE_FAILURE);

          this->configureInBuffer( pBuffer , bufferSize );

          // deserialize and call the user call back function
          if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , availableMeList ) )
            throw StatusCodeException(STATUS_CODE_FAILURE);

          for(std::vector<MonitorElementClientListener *>::iterator iter = m_listeners.begin(), endIter = m_listeners.end() ;
              endIter != iter ; ++iter)
            (*iter)->monitorElementsAvailable(this, availableMeList);
        }
        catch(StatusCodeException &exception)
        {
          LOG4CXX_WARN( dqmMainLogger , "Couldn't receive available me: " << exception.toString() );
        }
        catch(...)
        {
        }
      }
    }

    //-------------------------------------------------------------------------------------------------

    bool MonitorElementClient::isCollectorRunning() const
    {
      return m_isCollectorRunning;
    }

    //-------------------------------------------------------------------------------------------------

    void MonitorElementClient::configureInBuffer( char *pBuffer , uint32_t bufferSize )
    {
      if( ! m_pInBuffer )
        m_pInBuffer = new xdrstream::BufferDevice( pBuffer , bufferSize , false );
      else
        m_pInBuffer->setBuffer( pBuffer , bufferSize , false );

      m_pInBuffer->setOwner( false );
    }

  }

}
